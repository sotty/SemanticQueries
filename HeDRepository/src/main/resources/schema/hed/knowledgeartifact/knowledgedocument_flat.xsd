<?xml version="1.0"?>
<xs:schema elementFormDefault="qualified" targetNamespace="urn:hl7-org:knowledgeartifact:r1"
    xmlns="urn:hl7-org:knowledgeartifact:r1" xmlns:dt="urn:hl7-org:cdsdt:r2"
    xmlns:sch="http://purl.oclc.org/dsdl/schematron" xmlns:xhtml="http://www.w3.org/1999/xhtml"
    xmlns:xs="http://www.w3.org/2001/XMLSchema">
    <xs:annotation>
        <xs:documentation>    This file defines the root knowledge document type and element.
        </xs:documentation>
    </xs:annotation>
    <xs:annotation>
        <xs:documentation>    This file defines the meta data components used within a knowledge
            artifact.   </xs:documentation>
    </xs:annotation>
    <xs:import namespace="urn:hl7-org:cdsdt:r2" schemaLocation="../common/datatypes.xsd"/>
    <!--  xs:import namespace="http://www.w3.org/1999/xhtml" schemaLocation="../common/xhtml1-strict.xsd"/-->
    <xs:annotation>
        <xs:documentation>    This file defines the base types used in defining knowledge artifacts.
        </xs:documentation>
    </xs:annotation>
    <xs:annotation>
        <xs:documentation>    This file defines the ResourceRelationshipType enumeration.
        </xs:documentation>
    </xs:annotation>
    <xs:annotation>
        <xs:documentation>    This file allows organizations to extend the enumeration
            ResourceRelationshipType.    </xs:documentation>
    </xs:annotation>
    <xs:annotation>
        <xs:documentation>    This file defines the core values available within the
            ResourceRelationshipType enumeration.   </xs:documentation>
    </xs:annotation>
    <xs:simpleType name="ResourceRelationshipTypeCore">
        <xs:restriction base="xs:string">
            <xs:enumeration value="AdaptedFrom"/>
            <xs:enumeration value="AssociatedResource"/>
            <xs:enumeration value="DependsOn"/>
            <xs:enumeration value="DerivedFrom"/>
            <xs:enumeration value="SimilarTo"/>
            <xs:enumeration value="VersionOf"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ResourceRelationshipTypeExt">
        <xs:annotation>
            <xs:documentation>    To add new items to the enumeration ArtifactStatus, comment out or
                delete the restriction on ArtifactStatusTypeCore.(Optionally, also remove    the
                directive above to include the artifactstatustypecore.xsd).    Now, add a new
                restriction such as on string and define new enumerated types. See the commented out
                example below. !!! BKM get example from
                ArtifactLifeCycleEventTypeExt</xs:documentation>
        </xs:annotation>
        <xs:restriction base="ResourceRelationshipTypeCore"/>
    </xs:simpleType>
    <xs:simpleType name="ResourceRelationshipType">
        <xs:annotation>
            <xs:documentation>A specific status is associated with each version of an artifact.
                See the Implementation Guide for a state-transition diagram showing the legal
                transitions from each state; each state is equivalent to particular
                status.</xs:documentation>
        </xs:annotation>
        <xs:union memberTypes="ResourceRelationshipTypeCore ResourceRelationshipTypeExt"/>
    </xs:simpleType>
    <xs:complexType name="SupportingEvidence">
        <xs:annotation>
            <xs:documentation>The evidence grade and the sources of evidence     associated with
                this artifact.    </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element form="qualified" maxOccurs="unbounded" name="evidence" type="Evidence">
                <xs:annotation>
                    <xs:documentation>A single evidence reference.</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="SupportingResource">
        <xs:annotation>
            <xs:documentation>Didactic or other informational resources     associated with the
                artifact that can be provided to the CDS     recipient. Information resources can
                include inline text commentary     and links to web resources.Note, supporting
                resources excludes     supporting evidence. For supporting evidence, use
                SupportingEvidence.    </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element form="qualified" maxOccurs="unbounded" name="resource"
                type="KnowledgeResource">
                <xs:annotation>
                    <xs:documentation>An individual supporting resource.      </xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType abstract="true" name="Party">
        <xs:annotation>
            <xs:documentation>Party represents the abstract base type for entities that have
                addresses and contact information. It is intended to be extended and specialized by
                the Person and Organization concept. Note that Party allows for polymorphism using
                the xsi:type construct. For instance, by defining a 'contributor' to be of type
                'Party', one allows the contributor to be either a person or a company (its derived
                types).    </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element form="qualified" minOccurs="0" name="addresses">
                <xs:annotation>
                    <xs:documentation>The set of addresses associated with this
                        entity.</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:element form="qualified" maxOccurs="unbounded" name="address"
                            type="dt:AD">
                            <xs:annotation>
                                <xs:documentation>An individual address of type AD associated with
                                    this entity.</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
            <xs:element form="qualified" minOccurs="0" name="contacts">
                <xs:annotation>
                    <xs:documentation>The set of contact information associated with this
                        entity.</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:element form="qualified" maxOccurs="unbounded" name="contact"
                            type="dt:TEL">
                            <xs:annotation>
                                <xs:documentation>An individual contact item of type TEL associated
                                    with this entity.</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="Organization">
        <xs:annotation>
            <xs:documentation>Identifies an organization, a corporation, an institution, or a
                government department that has relevance to the knowledge artifact. Note that
                organization extends Party by adding a name attribute of type ST.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Party">
                <xs:sequence>
                    <xs:element form="qualified" name="name" type="dt:ST">
                        <xs:annotation>
                            <xs:documentation>The name of the organization.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Person">
        <xs:annotation>
            <xs:documentation>Identifies a person who is associated with the knowledge artifact. A
                person may be a contributor, a rights holder, a publisher, and so on. Person extends
                party by adding a person name attribute and an affiliation. Note, Person.name should
                be constrained to be of type EN.PN    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Party">
                <xs:sequence>
                    <xs:element form="qualified" name="name" type="dt:EN">
                        <xs:annotation>
                            <xs:documentation>The name of the person.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element form="qualified" minOccurs="0" name="affiliation"
                        type="Organization">
                        <xs:annotation>
                            <xs:documentation>The organizational affiliation for this
                                person.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="ResourceRelationshipReference">
        <xs:annotation>
            <xs:documentation>ResourceRelationshipReference defines the     association between a
                resource and a resource set. If one consider     such relationship as a triple
                (subject-predicate-object or     node-arc-node) with the source entity as the
                subject of the triple,     then ResourceRelationshipType defines the predicate and
                the object     of this relationship.    </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element form="qualified" name="relationship">
                <xs:annotation>
                    <xs:documentation>Relationship defines the association between two
                        resources - i.e., the predicate/arc of a triple. The object of the
                        relationship is often a pre-existing resource that predates the
                        subject of the relationship. This predicate can be one of six       types:
                        (1) AdaptedFrom - the subject was adapted from the object       of the
                        relationship. For instance, a diabetes visit order set may       be adapted
                        from the HbA1c reminder (2) AssociatedResource - the       object is
                        associated with the subject. For instance, an HbA1c       reminder may be
                        associated with an HbA1c eMeasure (3) DependsOn -       the subject depends
                        on the object. For instance, an HbA1c reminder       may depend on a
                        Diabetes Value Set (4) DerivedFrom - the subject       was derived from the
                        object. For instance, an HbA1c reminder rule       may be derived from a
                        Diabetes Guideline (5) SimilarTo - the       subject and object are similar.
                        For instance, an HbA1c reminder       may be similar to an LDL reminder and
                        (6) VersionOf - the subject       is a version of the object (and
                        vice-versa). For instance, the       HbA1c reminder v2 may be a version of
                        the HbA1c reminder v1.      </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:attribute name="value" type="ResourceRelationshipType" use="required"/>
                </xs:complexType>
            </xs:element>
            <xs:element form="qualified" minOccurs="1" name="resources">
                <xs:annotation>
                    <xs:documentation>The set of resources associated with the subject       of this
                        relationship.      </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:element form="qualified" maxOccurs="unbounded" name="resource"
                            type="KnowledgeResource">
                            <xs:annotation>
                                <xs:documentation>An associated resource instance.
                                </xs:documentation>
                            </xs:annotation>
                        </xs:element>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="InlineResource">
        <xs:annotation>
            <xs:documentation>An Inline Resource consists of both the resource     reference
                information and the actual resource content/payload to be     inserted inline. The
                content of the document must be represented in     valid xhtml format within the
                content/div node.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="KnowledgeResource">
                <xs:sequence>
                    <xs:element form="qualified" minOccurs="0" name="content">
                        <xs:annotation>
                            <xs:documentation>The document content in xhtml format.
                            </xs:documentation>
                        </xs:annotation>
                        <xs:complexType>
                            <xs:sequence>
                                <xs:element name="content" type="xs:string" />
                            </xs:sequence>
                        </xs:complexType>
                    </xs:element>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Evidence">
        <xs:annotation>
            <xs:documentation>Reference to research on which the artifact is     based. This
                evidence can be 'graded' depending on its quality and     pedigree and the strength
                of the recommendations it makes.    </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="qualityOfEvidence"
                type="dt:CD">
                <xs:annotation>
                    <xs:documentation>The quality of the evidence associated with this
                        artifact. The codeSystem attribute specifies the quality scale       used to
                        grade this evidence source while the code specifies the       actual quality
                        score (represented as a coded value) associated       with this evidence
                        reference. CodeSystemName specifies the name of       the scale. DisplayName
                        specifies the display name of the coded       value (the score).
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="strengthOfRecommendation"
                type="dt:CD">
                <xs:annotation>
                    <xs:documentation>The strength of the recommendation assigned to       this
                        reference. The codeSystem attribute specifies the scale used       to grade
                        this evidence source while the code specifies the actual       score
                        (represented as a coded value) for the strength of the       evidence.
                        CodeSystemName specifies the name of the scale.       DisplayName specifies
                        the display name of the coded value (the       score).
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="resources"
                type="SupportingResource">
                <xs:annotation>
                    <xs:documentation>The set of resource references associated with       the
                        evidence.      </xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="KnowledgeResource">
        <xs:annotation>
            <xs:documentation>KnowledgeResource specifies a reference to an     associated resource
                of relevance to the artifact such as a     guideline, a performance measure, another
                knowledge artifact, or a     source of evidence for the artifact.
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element form="qualified" minOccurs="0" name="identifiers">
                <xs:annotation>
                    <xs:documentation>The set of unique identifiers for this resource.
                    </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:element form="qualified" name="identifier" type="VersionedIdentifier">
                            <xs:annotation>
                                <xs:documentation>A unique resource identifier.
                                </xs:documentation>
                            </xs:annotation>
                        </xs:element>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
            <xs:element form="qualified" minOccurs="0" name="templateIds">
                <xs:annotation>
                    <xs:documentation>The set of unique identifiers for the templates
                        associated with this resource.      </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:element form="qualified" name="templateId" type="dt:II">
                            <xs:annotation>
                                <xs:documentation>A unique identifier for the template
                                    associated with this resource. Templates are used to constrain
                                    the resource model. For more information on this process,
                                    please refer to the implementation guide.
                                </xs:documentation>
                            </xs:annotation>
                        </xs:element>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
            <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="title" type="dt:ST">
                <xs:annotation>
                    <xs:documentation>The title of the document</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="location" type="dt:TEL">
                <xs:annotation>
                    <xs:documentation>The URL of the given resource.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="description" type="dt:ST">
                <xs:annotation>
                    <xs:documentation>A short textual description of the resource.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="citation" type="dt:ST">
                <xs:annotation>
                    <xs:documentation>The resource citation.</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="VersionedIdentifier">
        <xs:annotation>
            <xs:documentation>VersionedIdentifier is composed of two parts: (1)     an II identifier
                which identifies the set of all versions of a given     resource. (2) the actual
                version of the instance of interest in this     set. The VersionedIdentifier
                therefore points to an individual     'versioned' instance of a resource such as the
                third version of a     reminder rule.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="dt:II">
                <xs:attribute name="version" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:annotation>
        <xs:documentation>    This file defines the ArtifactLifeCycleEventType enumeration.
        </xs:documentation>
    </xs:annotation>
    <xs:annotation>
        <xs:documentation>    This file allows organizations to extend the enumeration
            ArtifactLifeCycleEventType.    </xs:documentation>
    </xs:annotation>
    <xs:annotation>
        <xs:documentation>    This file defines the core values available within the
            ArtifactLifeCycleEventType enumeration.   </xs:documentation>
    </xs:annotation>
    <xs:simpleType name="ArtifactLifeCycleEventTypeCore">
        <xs:annotation>
            <xs:documentation>A lifecycle event is applicable to a specific version of an artifact.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="Created">
                <xs:annotation>
                    <xs:documentation>The date/time when a particular version of an artifact is
                        created may be recorded in the history of the
                        artifact-version.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="Pre-published">
                <xs:annotation>
                    <xs:documentation>An artifact may be made available to consumers in a
                        pre-publication state for public commentary, etc., or may simply be made
                        available for review internal to the publisher.  This event can be recorded
                        in the artifact-version's history.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="Published"/>
            <xs:enumeration value="Reviewed">
                <xs:annotation>
                    <xs:documentation>A specific version of artifact may be reviewed by parties
                        internal or external to the publisher, and this can be recorded in the
                        lifecycle of the artifact-version.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="Withdrawn">
                <xs:annotation>
                    <xs:documentation>A specific version of an artifact may be withdrawn by a
                        publisher for various reasons.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="Superseded">
                <xs:annotation>
                    <xs:documentation>A specific version of an artifact may be superseded by another
                        version of that same artifact, or by another artifact
                        altogether.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ArtifactLifeCycleEventTypeExt">
        <xs:annotation>
            <xs:documentation>    To add new items to the enumeration ArtifactLifeCycleEvent,
                comment out or delete the restriction on ArtifactLifeCycleEventTypeCore.(Optionally,
                also remove    the directive above to include the
                artifactlifecycleeventtypecore.xsd).    Now, add a new restriction such as on string
                and define new enumerated types. See the commented out example below
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="ArtifactLifeCycleEventTypeCore"/>
        <!--
			<xs:restriction base="xs:string">
				<xs:enumeration value="Erased"/>
				<xs:enumeration value="Restored"/>
			</xs:restriction>
	 -->
    </xs:simpleType>
    <xs:simpleType name="ArtifactLifeCycleEventType">
        <xs:annotation>
            <xs:documentation>A version of an artifact may have different actions performed on it
                during the course of its life cycle.  Each action is considered an artifact life
                cycle event, and may be recorded in the history of that version of the artifact.
                See the Implementation Guide for a state-transition diagram showing the legal
                transitions from each state; each transition is equivalent to an
                event.</xs:documentation>
        </xs:annotation>
        <xs:union memberTypes="ArtifactLifeCycleEventTypeCore ArtifactLifeCycleEventTypeExt"/>
    </xs:simpleType>
    <xs:annotation>
        <xs:documentation>    This file defines the ArtifactStatusType enumeration.
        </xs:documentation>
    </xs:annotation>
    <xs:annotation>
        <xs:documentation>    This file allows organizations to extend the enumeration
            ArtifactStatusType.    </xs:documentation>
    </xs:annotation>
    <xs:annotation>
        <xs:documentation>    This file defines the core values available within the
            ArtifactStatusType enumeration.   </xs:documentation>
    </xs:annotation>
    <xs:simpleType name="ArtifactStatusTypeCore">
        <xs:restriction base="xs:string">
            <xs:enumeration value="Draft">
                <xs:annotation>
                    <xs:documentation/>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="InTest"/>
            <xs:enumeration value="Active"/>
            <xs:enumeration value="Inactive"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ArtifactStatusTypeExt">
        <xs:annotation>
            <xs:documentation>    To add new items to the enumeration ArtifactStatus, comment out or
                delete the restriction on ArtifactStatusTypeCore.(Optionally, also remove    the
                directive above to include the artifactstatustypecore.xsd).    Now, add a new
                restriction such as on string and define new enumerated types. See the commented out
                example below. !!! BKM get example from
                ArtifactLifeCycleEventTypeExt</xs:documentation>
        </xs:annotation>
        <xs:restriction base="ArtifactStatusTypeCore"/>
    </xs:simpleType>
    <xs:simpleType name="ArtifactStatusType">
        <xs:annotation>
            <xs:documentation>A specific status is associated with each version of an artifact.
                See the Implementation Guide for a state-transition diagram showing the legal
                transitions from each state; each state is equivalent to particular
                status.</xs:documentation>
        </xs:annotation>
        <xs:union memberTypes="ArtifactStatusTypeCore ArtifactStatusTypeExt"/>
    </xs:simpleType>
    <xs:annotation>
        <xs:documentation>    This file defines the ArtifactType enumeration.   </xs:documentation>
    </xs:annotation>
    <xs:annotation>
        <xs:documentation>    This file allows organizations to extend the enumeration ArtifactType.
        </xs:documentation>
    </xs:annotation>
    <xs:annotation>
        <xs:documentation>    This file defines the core values available within the ArtifactType
            enumeration.   </xs:documentation>
    </xs:annotation>
    <xs:simpleType name="ArtifactTypeCore">
        <xs:restriction base="xs:string">
            <xs:enumeration value="Rule">
                <xs:annotation>
                    <xs:documentation>Denotes an Event-Condition-Action Rule.  An ECA rule has a
                        specific structure that is a restriction on the general structure of a CDS
                        Knowledge Artifact.  See the Implementation Guide for the constraints
                        applicable to ECA rules.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="Order Set">
                <xs:annotation>
                    <xs:documentation>Denotes an Order Set for use by physicians at the point of
                        care.  An Order Set has a specific structure that is a restriction on the
                        general structure of a CDS Knowledge Artifact.  See the Implementation Guide
                        for the constraints applicable to Order Sets.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="Documentation Template">
                <xs:annotation>
                    <xs:documentation>Denotes a Documentation Template for use by care providers.  A
                        Documentation Template has a specific structure that is a restriction on the
                        general structure of a CDS Knowledge Artifact.  See the Implementation Guide
                        for the constraints applicable to Documentation
                        Templates.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ArtifactTypeExt">
        <xs:restriction base="ArtifactTypeCore"/>
    </xs:simpleType>
    <xs:simpleType name="ArtifactType">
        <xs:annotation>
            <xs:documentation>Three types of artifacts are in scope for Health eDecisions Use Case
                #1:  Event-condition-action rules, order sets and documentation
                templates.</xs:documentation>
            <!-- BTR-> There was a comment within the documentation here:   In addition, a CDS artifact may also be a value set.  !!! Get more info from Aziz about this ...  !!! -->
        </xs:annotation>
        <xs:union memberTypes="ArtifactTypeCore ArtifactTypeExt"/>
    </xs:simpleType>
    <xs:annotation>
        <xs:documentation>    This file defines the ContributorType enumeration.
        </xs:documentation>
    </xs:annotation>
    <xs:annotation>
        <xs:documentation>    This file defines the core values available within the ContributorType
            enumeration.   </xs:documentation>
    </xs:annotation>
    <xs:simpleType name="ContributorTypeCore">
        <xs:restriction base="xs:string">
            <xs:enumeration value="Author"/>
            <xs:enumeration value="Editor"/>
            <xs:enumeration value="Endorser"/>
            <xs:enumeration value="Reviewer"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:annotation>
        <xs:documentation>    This file allows organizations to extend the enumeration
            ContributorType.    </xs:documentation>
    </xs:annotation>
    <xs:simpleType name="ContributorTypeExt">
        <xs:restriction base="ContributorTypeCore"/>
    </xs:simpleType>
    <xs:simpleType name="ContributorType">
        <xs:annotation>
            <xs:documentation>Enumeration of roles that contribute to the development and
                maintenance of a knowledge artifact.</xs:documentation>
        </xs:annotation>
        <xs:union memberTypes="ContributorTypeCore ContributorTypeExt"/>
    </xs:simpleType>
    <xs:annotation>
        <xs:documentation>    This file defines the CoverageType enumeration.   </xs:documentation>
    </xs:annotation>
    <xs:annotation>
        <xs:documentation>    This file allows organizations to extend the enumeration CoverageType.
        </xs:documentation>
    </xs:annotation>
    <xs:annotation>
        <xs:documentation>    This file defines the core values available within the CoverageType
            enumeration.   </xs:documentation>
    </xs:annotation>
    <xs:simpleType name="CoverageTypeCore">
        <xs:restriction base="xs:string">
            <xs:enumeration value="PatientGender">
                <xs:annotation>
                    <xs:documentation>The gender of the patient. For this item type, use HL7
                        administrative gender codes (OID:
                        2.16.840.1.113883.1.11.1)</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="PatientAgeGroup">
                <xs:annotation>
                    <xs:documentation>A patient demographic category for which this artifact is
                        applicable. Allows specification of age groups using coded values
                        originating from the MeSH Code system (OID: 2.16.840.1.113883.6.177). More
                        specifically, only codes from the AgeGroupObservationValue value set are
                        valid for this field  [2.16.840.1.113883.11.75]</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="ClinicalFocus">
                <xs:annotation>
                    <xs:documentation>The clinical concept(s) addressed by the artifact.  For
                        example, disease, diagnostic test interpretation, medication ordering.
                        Please refer to the implementation guide on which code system and codes to
                        use.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="TargetUser">
                <xs:annotation>
                    <xs:documentation>The user types to which an artifact is targeted.  For example,
                        PCP, Patient, Cardiologist, Behavioral Professional, Oral Health
                        Professional, Prescriber, etc... taken from the NUCC Health Care provider
                        taxonomyCode system (OID: 2.16.840.1.113883.6.101)</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="WorkflowSetting">
                <xs:annotation>
                    <xs:documentation>The settings in which the artifact is intended for use.  For
                        example, admission, pre-op, etc.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="WorkflowTask">
                <xs:annotation>
                    <xs:documentation>The context for the clinical task(s) represented by this
                        artifact. Can be any task context represented by the HL7 ActTaskCode value
                        set (OID: 2.16.840.1.113883.1.11.19846). General categories include: order
                        entry, patient documentation and patient information
                        review</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="ClinicalVenue">
                <xs:annotation>
                    <xs:documentation>The venue in which an artifact could be used.  For example,
                        Outpatient, Inpatient, Home, Nursing home. The code value may originate from
                        either the HL7 ActEncounter (OID: 2.16.840.1.113883.1.11.13955) or NUCC
                        non-individual provider codes OID:
                        2.16.840.1.113883.1.11.19465</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="CoverageTypeExt">
        <xs:restriction base="CoverageTypeCore"/>
    </xs:simpleType>
    <xs:simpleType name="CoverageType">
        <xs:annotation>
            <xs:documentation>Specifies clinical metadata that can be used to retrieve, index and/or
                categorize the knowledge artifact. This metadata can either be specific to the
                applicable population (e.g., age category, DRG) or the specific context of care
                (e.g., venue, care setting, provider of care). </xs:documentation>
        </xs:annotation>
        <xs:union memberTypes="CoverageTypeCore CoverageTypeExt"/>
    </xs:simpleType>
    <xs:complexType name="ArtifactLifeCycleEvent">
        <xs:annotation>
            <xs:documentation>An event in the life cycle of an artifact. Both the     type of event
                are specified, as well as the point in time in which     that event took place.
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element form="qualified" name="eventType">
                <xs:complexType>
                    <xs:attribute name="value" type="ArtifactLifeCycleEventType" use="required"/>
                </xs:complexType>
            </xs:element>
            <xs:element form="qualified" name="eventDateTime" type="dt:TS"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="Contribution">
        <xs:annotation>
            <xs:documentation>A contribution is made by a specific contributor     (organization,
                person, etc.), and was made in a particular way, as     specified by the
                contributor's role. For example, a contributor may     have been an author, or may
                have been a reviewer.    </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element form="qualified" name="contributor" type="Party"/>
            <xs:element form="qualified" name="role">
                <xs:complexType>
                    <xs:attribute name="value" type="ContributorType"/>
                </xs:complexType>
            </xs:element>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="Coverage">
        <xs:annotation>
            <xs:documentation>Specifies various attributes of the patient     population for whom
                and/or environment of care in which the CDS     artifact is applicable.
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element form="qualified" name="focus">
                <xs:complexType>
                    <xs:attribute name="value" type="CoverageType" use="required"/>
                </xs:complexType>
            </xs:element>
            <xs:element form="qualified" minOccurs="0" name="description" type="dt:ST"/>
            <xs:element form="qualified" minOccurs="0" name="value" type="dt:CD"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="Metadata">
        <xs:annotation>
            <xs:documentation>The container for all of the metadata associated     with a CDS
                knowledge artifact. Ideally, the metadata for artifacts     is provided
                independently by the publisher for determining which     artifact to retrieve.
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element form="qualified" name="identifiers">
                <xs:annotation>
                    <xs:documentation>Each version of a CDS knowledge artifact may have more than
                        one identifier associated with it.  Note that each identifier must be
                        globally unique in the universe of CDS knowledge artifacts in which a
                        particular artifact resides.</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:element form="qualified" maxOccurs="unbounded" name="identifier"
                            type="VersionedIdentifier">
                            <xs:annotation>
                                <xs:documentation>The identifier of a CDS knowledge artifact
                                    consists of two parts:  (1) a base identifier which uniquely
                                    identifies the CDS Knowledge Artifact from all other CDS
                                    Knowledge Artifacts, regardless of version.  (2) a version
                                    identifier which uniquely identifies the CDS Knowledge Artifact
                                    from all other CDS Knowledge Artifact versions.  Essentially,
                                    the full identifier is for a particular "artifact
                                    version".</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
            <xs:element form="qualified" name="artifactType">
                <xs:annotation>
                    <xs:documentation>Currently three types of artifacts are in scope for Health
                        eDecisions Use Case #1:  order sets, event-condition-action rules, and
                        documentation templates.  Additional types will be added in future revisions
                        of the standard.</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:attribute name="value" type="ArtifactType" use="required"/>
                </xs:complexType>
            </xs:element>
            <xs:element form="qualified" name="schemaIdentifier" type="VersionedIdentifier">
                <xs:annotation>
                    <xs:documentation>This is the identifier of the XML schema (and its version)
                        which governs the structure of this CDS Knowledge
                        Artifact.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element form="qualified" minOccurs="0" name="templateIds">
                <xs:annotation>
                    <xs:documentation>These are the identifiers of templates which       further
                        constrain the structure of this knowledge artifact.      </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:element form="qualified" maxOccurs="unbounded" name="templateId"
                            type="VersionedIdentifier"/>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
            <xs:element form="qualified" minOccurs="0" name="dataModels">
                <xs:annotation>
                    <xs:documentation>Set of data models referenced in the Expression       objects
                        in this knowledge artifact.      </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:element form="qualified" maxOccurs="unbounded" name="modelReference"
                            type="ModelReference">
                            <xs:annotation>
                                <xs:documentation>A reference for the data models that are
                                    used in the artifact, e..g., the Virtual Medical Record. In
                                    this case, the name could be "vmr" and the value is          the
                                    namespace universal resource identifier of the HL7 VMR schema
                                </xs:documentation>
                            </xs:annotation>
                        </xs:element>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
            <xs:element form="qualified" name="title" type="dt:ST"/>
            <xs:element form="qualified" minOccurs="0" name="description" type="dt:ST"/>
            <xs:element form="qualified" minOccurs="0" name="documentation" type="InlineResource">
                <xs:annotation>
                    <xs:documentation>Documentation for this knowledge reference may       consist
                        of a reference to an external resource; the documentation       may also be
                        included in-line if desired.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element form="qualified" minOccurs="0" name="relatedResources">
                <xs:annotation>
                    <xs:documentation>A set of resources related to this artifact,       along with
                        an indication of the type of relationship. An artifact       may be derived
                        from or depend on other artifacts, along with other       types of
                        relationships. See the Artifact Lifecycle diagram in the
                        Implementation Guide for more information.</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:element form="qualified" maxOccurs="unbounded" name="relatedResource"
                            type="ResourceRelationshipReference"/>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
            <xs:element form="qualified" minOccurs="0" name="supportingEvidence"
                type="SupportingEvidence"/>
            <xs:element form="qualified" minOccurs="0" name="applicability">
                <xs:annotation>
                    <xs:documentation>Specifies the conditions under which this       artifact is
                        applicable.</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:element form="qualified" maxOccurs="unbounded" name="coverage"
                            type="Coverage"/>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
            <xs:element form="qualified" minOccurs="0" name="keyTerms">
                <xs:annotation>
                    <xs:documentation>Provides a list of coded key terms that pertain to this
                        artifact.</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:element form="qualified" maxOccurs="unbounded" name="term" type="dt:CD"
                        />
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
            <xs:element form="qualified" minOccurs="0" name="categories">
                <xs:annotation>
                    <xs:documentation>Provides a list of coded categories to which this
                        artifact belongs.      </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:element form="qualified" maxOccurs="unbounded" name="category"
                            type="dt:CD"/>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
            <xs:element form="qualified" minOccurs="0" name="language" type="dt:CD"/>
            <xs:element form="qualified" name="status">
                <xs:complexType>
                    <xs:attribute name="value" type="ArtifactStatusType" use="required"/>
                </xs:complexType>
            </xs:element>
            <xs:element form="qualified" minOccurs="0" name="eventHistory">
                <xs:annotation>
                    <xs:documentation>This is the history of events which have occurred       for
                        this particular version of the artifact.      </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:element form="qualified" maxOccurs="unbounded"
                            name="artifactLifeCycleEvent" type="ArtifactLifeCycleEvent"/>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
            <xs:element form="qualified" minOccurs="0" name="contributions">
                <xs:annotation>
                    <xs:documentation>Includes a list of people and/or organizations       who have
                        contributed to the development of this artifact.       Contributions are not
                        necessarily tied to specific versions of the
                        artifact.</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:element form="qualified" maxOccurs="unbounded" name="contribution"
                            type="Contribution"/>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
            <xs:element form="qualified" minOccurs="0" name="publishers">
                <xs:annotation>
                    <xs:documentation>The set of people and/or organizations who       publish the
                        artifact.</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:element form="qualified" maxOccurs="unbounded" name="publisher"
                            type="Party"/>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
            <xs:element form="qualified" minOccurs="0" name="usageTerms">
                <xs:annotation>
                    <xs:documentation>This is the set of rights reserved by the person       or
                        organization holding the rights to this artifact, along with       the set
                        of permissions granted to consumers.</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:element form="qualified" maxOccurs="unbounded" name="rightsDeclaration"
                            type="RightsDeclaration"/>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="RightsDeclaration">
        <xs:annotation>
            <xs:documentation>This specifies the intellectual property rights     associated with
                this CDS knowledge artifact, including who the     rights holder is and what rights
                they assert. It also specifies what     permissions are granted for usage. The
                asserted rights and     persmissions are specified as a free-form text string.
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element form="qualified" name="assertedRights" type="dt:ST"/>
            <xs:element form="qualified" name="rightsHolder" type="Party"/>
            <xs:element form="qualified" minOccurs="0" name="permissions">
                <xs:complexType>
                    <xs:sequence>
                        <xs:element form="qualified" maxOccurs="unbounded" name="permissions"
                            type="dt:ST"/>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="ModelReference">
        <xs:annotation>
            <xs:documentation>A reference to some model by its Universal Resource Identifier.
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element form="qualified" name="description" type="dt:ST">
                <xs:annotation>
                    <xs:documentation>The object is assigned a name that can be used in       this
                        artifact.      </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element form="qualified" name="referencedModel">
                <xs:annotation>
                    <xs:documentation>The identifier of the object that is being       referenced.
                    </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:attribute name="value" type="xs:anyURI">
                        <xs:annotation>
                            <xs:documentation>The URI of the object that is being referenced. This
                                URL must also be defined as a namespace in the root element of the
                                document</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:complexType>
            </xs:element>
        </xs:sequence>
    </xs:complexType>
    <xs:annotation>
        <xs:documentation>    This file defines the Action types used to describe guidance within a
            knowledge artifact.    </xs:documentation>
    </xs:annotation>
    <xs:annotation>
        <xs:documentation>    This file defines the core expression components used throughout
            knowledge artifacts. The core expression components defined here are intended to be
            general purpose, and beyond the datatypes in the cdsdt namespace, do not reference
            anything specific to the clinical decision support domain. This layering is intended to
            isolate the syntactic elements of a general purpose expression language from the more
            frequently varying elements of clinical decision support.   </xs:documentation>
    </xs:annotation>
    <xs:complexType abstract="true" name="Expression">
        <xs:annotation>
            <xs:documentation>     The Expression type defines the abstract base type for all
                expressions used in the     HeDS expression language.    </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="description"
                type="xs:string"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType abstract="true" name="UnaryExpression">
        <xs:annotation>
            <xs:documentation>     The UnaryExpression type defines the abstract base type for all
                expressions     that take a single argument.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="operand"
                        type="Expression"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="BinaryExpression">
        <xs:annotation>
            <xs:documentation>     The BinaryExpression type defines the abstract base type for all
                expressions      that take two arguments.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="2" minOccurs="2" name="operand"
                        type="Expression"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="TernaryExpression">
        <xs:annotation>
            <xs:documentation>     The TernaryExpression type defines the abstract base type for all
                expressions      that take three arguments.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="3" minOccurs="3" name="operand"
                        type="Expression"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType abstract="true" name="NaryExpression">
        <xs:annotation>
            <xs:documentation>     The Expression type defines an abstract base class for an
                expression     that takes any number of arguments, including zero.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="operand"
                        type="Expression"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="ExpressionDef">
        <xs:annotation>
            <xs:documentation>     The ExpressionDef type defines an expression and an associated
                name that can be referenced by any expression in the artifact.     The name must be
                unique within the artifact.    </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element form="qualified" name="expression" type="Expression"/>
        </xs:sequence>
        <xs:attribute name="name" type="xs:string"/>
    </xs:complexType>
    <xs:complexType name="ExpressionRef">
        <xs:annotation>
            <xs:documentation>     The ExpressionRef type defines an expression that references a
                previously defined NamedExpression. The result of evaluating an
                ExpressionReference is the result of evaluating the referenced     NamedExpression.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:attribute name="name" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="ParameterDef">
        <xs:annotation>
            <xs:documentation>     ParameterDef defines a parameter that can be referenced by name
                anywhere within an expression. Parameters are defined at the artifact     level, and
                may be provided as part of the payload for an evaluation     request. If no
                parameter value is provided, the default element is     used to provide the value
                for the parameter. If no parameter or     default is provided, the parameter is
                defined to be null.    </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="default"
                type="Expression"/>
        </xs:sequence>
        <xs:attribute name="name" type="xs:string"/>
        <xs:attribute name="parameterType" type="xs:QName"/>
    </xs:complexType>
    <xs:complexType name="ParameterRef">
        <xs:annotation>
            <xs:documentation>     The ParameterRef expression allows the value of a parameter to be
                referenced     as part of an expression.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:attribute name="name" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- Literals -->
    <xs:complexType name="Literal">
        <xs:annotation>
            <xs:documentation>     The Literal type defines a single scalar value. For example, the
                literal 5,     the boolean value true or the string "Code".    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:attribute name="valueType" type="xs:QName" use="required"/>
                <xs:attribute name="value" type="xs:anySimpleType" use="optional"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- Complex literal is not included, the decision was made that this would introduce
	multiple different ways of accomplishing the same thing (namely with a ComplexLiteral, and with
	an ObjectExpression. Given that ObjectExpression is more powerful, it was selected as the preferred
	approach. Note that specific literals are included for the ISO data types. 

	UPDATE: Based on specific feedback from Zynx and others, it is proposed that the ComplexLiteral
	expression be reintroduced to allow static orderable content to be expressed without the need to
	build it up with an expression.
	-->
    <xs:complexType name="ComplexLiteral">
        <xs:annotation>
            <xs:documentation>     The ComplexLiteral expression allows an xml literal of any type
                to be     included in an expression.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="value"
                        type="xs:anyType"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="PropertyExpression">
        <xs:annotation>
            <xs:documentation>     The PropertyExpression type is used within the ObjectLiteral type
                to      provide the value of a specific property within an object literal
                expression.    </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="value" type="Expression"
            />
        </xs:sequence>
        <xs:attribute name="name" type="xs:string" use="required"/>
    </xs:complexType>
    <xs:complexType name="ObjectExpression">
        <xs:annotation>
            <xs:documentation>     The ObjectExpression type allows objects of any type to be built
                up as an expression. The objectType attribute specifies the type of      the object
                being built, and the list of property elements specify     the values for the
                properties of the object. Note that the value     of a property may be any
                expression, including another ObjectLiteral.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="property"
                        type="PropertyExpression"/>
                </xs:sequence>
                <xs:attribute name="objectType" type="xs:QName"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="ObjectDescriptor">
        <xs:annotation>
            <xs:documentation>     The ObjectDescriptor type allows arbitrary object descriptors to
                be built,     allowing for the creation of an value that has enough information to
                uniquely     identify an object, but is not the object itself. Object descriptors
                are used as     part of the update and remove action sentences to allow the object
                to be     updated to be described without creating the object itself.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="property"
                        type="PropertyExpression"/>
                </xs:sequence>
                <xs:attribute name="objectType" type="xs:QName"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="ObjectRedefine">
        <xs:annotation>
            <xs:documentation>     The ObjectRedefine expression returns an object of the same type
                as the     source argument, with the same values for each property, except the
                values     of the properties listed in the property elements. For those properties,
                the values will be set based on the expressions in those elements. This     operator
                allows an object to be "copied" with new values specified only     for a given list
                of properties.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="source"
                        type="Expression"/>
                    <xs:element form="qualified" maxOccurs="unbounded" minOccurs="1" name="property"
                        type="PropertyExpression"/>
                </xs:sequence>
                <xs:attribute name="scope" type="xs:string" use="optional"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- Interval selector -->
    <xs:complexType name="Interval">
        <xs:annotation>
            <xs:documentation>     The Interval selector defines an interval value. An interval must
                be defined     on values that support comparison, as well as successor and
                predecessor values.     The beginning and ending of the interval may each be defined
                as open or closed.     The default is closed, indicating an inclusive interval.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="begin"
                        type="Expression"/>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="end"
                        type="Expression"/>
                </xs:sequence>
                <xs:attribute default="false" name="beginOpen" type="xs:boolean" use="optional"/>
                <xs:attribute default="false" name="endOpen" type="xs:boolean" use="optional"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- Examples 

	<operand xsi:Type="Interval">
		<begin xsi:Type="Literal" valueType="xs:Date" value="2010-10-10"/>
		<end xsi:Type="Literal" valueType="xs:Date" value="2010-10-11"/>
	</operand>

	-->
    <xs:complexType name="List">
        <xs:annotation>
            <xs:documentation>     The List selector returns a value of type List, whose elements
                are the result     of evaluating the arguments to the List selector, in order.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="element"
                        type="Expression"/>
                </xs:sequence>
                <xs:attribute name="key" type="xs:string" use="optional"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- Logical Operators -->
    <xs:complexType name="And">
        <xs:annotation>
            <xs:documentation>     The And operator returns the logical conjunction of its
                arguments. Note that this     operator is defined as n-ary, allowing any number of
                arguments. The result     of And with no arguments is defined to be false. The
                result of an And with     a single argument is defined to be the result of the
                argument. The result of     and with two arguments is defined using 3-valued logic
                semantics. This means     that if either argument is false, the result is false; if
                both arguments     are true, the result is true; otherwise, the result is null. The
                result     of more than two arguments is defined as successive invocations of And.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="NaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Or">
        <xs:annotation>
            <xs:documentation>     The Or operator returns the logical disjunction of its arguments.
                Note that     this operator is defined as n-ary, allowing any number of arguments.
                The result     of Or with no arguments is defined to be true. The result of Or with
                a single     argument is defined to be the result of the argument. The result of Or
                with two     arguments is defined using 3-valued logic semantics. This means that if
                either     argument is true, the result is true; if both arguments are false, the
                result      is false; otherwise, the result is null. The result of more than two
                arguments     is defined as successive invocations of Or.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="NaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Not">
        <xs:annotation>
            <xs:documentation>     The Not operator returns the logical negation of its argument. If
                the argument     is true, the result is false; if the argument is false, the result
                is true;      otherwise, the result is null.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="UnaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Conditional">
        <xs:annotation>
            <xs:documentation>     The Conditional operator evaluates a condition, and returns the
                then     argument if condition evaluates to true; otherwise the result     of the
                else argument is returned.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="condition"
                        type="Expression"/>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="then"
                        type="Expression"/>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="else"
                        type="Expression"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- Examples
	<condition xsi:Type="Conditional">
		<condition xsi:type="Equal">
			<operand xsi:type="Property" Path="Name"/>
			<operand xsi:type="Literal" valueType="xs:string" value="Test"/>
		</condition>
		<then xsi:type="Literal" valueType="xs:string" value="Name was Test"/>
		<else xsi:type="Literal" valueType="xs:string" value="Name was not Test"/>
	</condition>
	-->
    <xs:complexType name="CaseItem">
        <xs:sequence>
            <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="when" type="Expression"/>
            <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="then" type="Expression"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="Case">
        <xs:annotation>
            <xs:documentation>     The case operator allows for multiple conditional expressions to
                be chained together in a single expression, rather than having to     nest multiple
                Conditional operators.      In addition, the comparand operand provides a variant on
                the case that     allows a single value to be compared in each conditional.      If
                a comparand is not provided, the type of each when element of the     caseItems
                within the Case is expected to be boolean.      If a comparand is provided, the type
                of each when element of the     caseItems within the Case is expected to be of the
                same type as the comparand.      An else element must always be provided.      The
                type of all then elements, and the else element, must be the same is,     and is the
                resulting type of the Case operator.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="comparand"
                        type="Expression"/>
                    <xs:element form="qualified" maxOccurs="unbounded" minOccurs="1" name="caseItem"
                        type="CaseItem"/>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="else"
                        type="Expression"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- Nullological Operators -->
    <!-- NOTE: Maybe may be implemented as a null-test on a boolean-valued expression. I am reluctant to introduce an actual Maybe operator
	because SQL doesn't have a MAYBE operator. (At least, most dialects don't). In fact, even the long-hand described previously (null-test
	on a boolean-valued expression) cannot be translated into SQL.
	-->
    <xs:complexType name="Null">
        <xs:annotation>
            <xs:documentation>     Returns a typed null.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:attribute name="valueType" type="xs:QName" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="IsNull">
        <xs:annotation>
            <xs:documentation>     Returns true if the argument evaluates to null, false otherwise.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="UnaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="IfNull">
        <xs:annotation>
            <xs:documentation>     If the first argument evaluates to null, returns the result of
                the      second argument. Otherwise, returns the result of the first argument.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="BinaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Coalesce">
        <xs:annotation>
            <xs:documentation>     Returns the result of the first argument that evaluates is not
                null.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="NaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <!-- Type Operators -->
    <xs:complexType name="Is">
        <xs:annotation>
            <xs:documentation>     Returns true if the argument is of the specified type.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="UnaryExpression">
                <xs:attribute name="isType" type="xs:QName" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="As">
        <xs:annotation>
            <xs:documentation>     Casts the argument as the specified type. If the argument is not
                of the specified type, strict determines whether the result is null (the default),
                or an exception is thrown.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="UnaryExpression">
                <xs:attribute name="asType" type="xs:QName" use="required"/>
                <xs:attribute default="false" name="strict" type="xs:boolean" use="optional"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Convert">
        <xs:annotation>
            <xs:documentation>     Converts a value to a specific type.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="UnaryExpression">
                <xs:attribute name="toType" type="xs:QName" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- Comparison Operators -->
    <xs:complexType name="Equal">
        <xs:annotation>
            <xs:documentation>     The Equal operator returns true if the arguments are equal; and
                false      otherwise. Equality semantics are defined to be value-based. This means
                for scalars that equality returns true if and only if the result of     each
                argument evaluates to the same value. For object types, this means     that equality
                returns true if and only if the objects are of the same     type, and the values for
                all properties are the same. For list types,     this means that equality returns
                true if and only if the lists contain     elements of the same type, have the same
                number of elements, and for     each element in the lists, the elements are equal
                using the same semantics.     For interval types, equality returns true if and only
                if the intervals     are over the same point type, and they have the same value for
                the     beginning and ending points of the interval. If either argument     is null,
                the result is null.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="BinaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="NotEqual">
        <xs:annotation>
            <xs:documentation>     The NotEqual operator returns true if its argument are not the
                same value.      The NotEqual operator is a shorthand for invocation of logical
                negation of the Equal operator.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="BinaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Less">
        <xs:annotation>
            <xs:documentation>     Returns true if the first argument is less than the second
                argument.     If either argument is null, the result is null.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="BinaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Greater">
        <xs:annotation>
            <xs:documentation>     Returns true if the first argument is greater than the second
                argument.     If either argument is null, the result is null.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="BinaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="LessOrEqual">
        <xs:annotation>
            <xs:documentation>     Returns true if the first argument is less than or equal to the
                second argument.     If either argument is null, the result is null.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="BinaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="GreaterOrEqual">
        <xs:annotation>
            <xs:documentation>     Returns true if the first argument is greater than or equal to
                the second argument.     If either argument is null, the result is null.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="BinaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <!-- Arithmetic Operators -->
    <xs:complexType name="Add">
        <xs:annotation>
            <xs:documentation>     The Add operator performs numeric addition of its arguments.
                If either argument is null, the result is null.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="BinaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Subtract">
        <xs:annotation>
            <xs:documentation>     The Subtract operator performs numeric subtraction of its
                arguments.     If either argument is null, the result is null.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="BinaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Multiply">
        <xs:annotation>
            <xs:documentation>     The Multiply operator performs numeric multiplication of its
                arguments.     If either argument is null, the result is null.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="BinaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Divide">
        <xs:annotation>
            <xs:documentation>     The Divide operator performs numeric division of its arguments.
                Note that the result of Divide is a decimal, even if its arguments     are integers.
                If either argument is null, the result is null.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="BinaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="TruncatedDivide">
        <xs:annotation>
            <xs:documentation>     The TruncatedDivide operator performs integer division of its
                arguments.     If either argument is null, the result is null.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="BinaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Modulo">
        <xs:annotation>
            <xs:documentation>     The Modulo operator computes the remainder of the division of its
                arguments. If either argument is null, the result is null.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="BinaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Ceiling">
        <xs:annotation>
            <xs:documentation>     The Ceiling operator returns the first integer greater than or
                equal to the argument. If the argument is null, the result is null.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="UnaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Floor">
        <xs:annotation>
            <xs:documentation>     The Floor operator returns the first integer less than or
                equal to the argument. If the argument is null, the result is null.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="UnaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Abs">
        <xs:annotation>
            <xs:documentation>     The Abs operator returns the absolute value of its argument.
                If the argument is null, the result is null.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="UnaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Negate">
        <xs:annotation>
            <xs:documentation>     The Negate operator returns the negative of its argument.     If
                the argument is null, the result is null.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="UnaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Round">
        <xs:annotation>
            <xs:documentation>     The Round operator returns the nearest integer to its
                argument. The semantics of round are defined as a traditional     round, meaning
                that a decimal value of 0.5 or higher will round     to 1. If the argument is null,
                the result is null.     If specified, precision determines the decimal place at
                which     the rounding will occur. If precision is not specified or null, 0 is
                assumed.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="operand"
                        type="Expression"/>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="precision"
                        type="Expression"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Ln">
        <xs:annotation>
            <xs:documentation>     The Ln operator computes the natural logarithm of its argument.
                If the argument is null, the result is null.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="UnaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Log">
        <xs:annotation>
            <xs:documentation>     The Log operator computes the logarithm of its first argument,
                using the second argument as the base.     If either argument is null, the result is
                null.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="BinaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Power">
        <xs:annotation>
            <xs:documentation>     The Power operator raises the first argument to the power
                given by the second argument.     If either argument is null, the result is null.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="BinaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Succ">
        <xs:annotation>
            <xs:documentation>     The Succ operator returns the successor of the argument.     For
                example, the successor of 1 is 2.     If the argument is null, the result is null.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="UnaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Pred">
        <xs:annotation>
            <xs:documentation>     The Pred operator returns the predecessor of the argument.
                For example, the predecessor of 2 is 1.     If the argument is null, the result is
                null.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="UnaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <!-- String Operators -->
    <xs:complexType name="Concat">
        <xs:annotation>
            <xs:documentation>     The Concat operator performs string concatenation     of its
                arguments.     If any argument is null, the result is null.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="NaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Combine">
        <xs:annotation>
            <xs:documentation>     The Combine operator combines a list of strings,     optionally
                separating each string with the given     separator.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="source"
                        type="Expression"/>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="separator"
                        type="Expression"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Split">
        <xs:annotation>
            <xs:documentation>     The Split operator splits a string into a list of strings using a
                separator. If the stringToSplit argument is null, the result is null.     If the
                stringToSplit argument does not contain any appearances of the     separator, the
                result is a list of strings containing one element that     is value of the
                stringToSplit argument.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="stringToSplit"
                        type="Expression"/>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="separator"
                        type="Expression"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Length">
        <xs:annotation>
            <xs:documentation>     Returns the length of its argument. For strings, the length is
                the number of     characters in the string. For intervals, the length is defined as
                the ending     point minus the beginning point.      If the argument is null, the
                result is null.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="UnaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Upper">
        <xs:annotation>
            <xs:documentation>     Returns the upper case of its argument.     If the argument is
                null, the result is null.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="UnaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Lower">
        <xs:annotation>
            <xs:documentation>     Returns the lower case of its argument.     If the argument is
                null, the result is null.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="UnaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="First">
        <xs:annotation>
            <xs:documentation>     Returns the first element in a list. If the order     by
                attribute is specified, the list is sorted by that     ordering prior to returning
                the first element.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" name="source" type="Expression"/>
                </xs:sequence>
                <xs:attribute name="orderBy" type="xs:string" use="optional"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Last">
        <xs:annotation>
            <xs:documentation>     Returns the last element in a list. If the order by     attribute
                is specified, the list is sorted by that     ordering prior to returning the last
                element.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" name="source" type="Expression"/>
                </xs:sequence>
                <xs:attribute name="orderBy" type="xs:string" use="optional"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Indexer">
        <xs:annotation>
            <xs:documentation>     Returns the indexth element in a string or list.     Indexes in
                strings and lists are defined to be one-based.     If either argument is null, the
                result is null.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="operand"
                        type="Expression"/>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="index"
                        type="Expression"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Pos">
        <xs:annotation>
            <xs:documentation>     Pos returns the 1-based index of the given pattern in the given
                string.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="pattern"
                        type="Expression"/>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="string"
                        type="Expression"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Substring">
        <xs:annotation>
            <xs:documentation>     Substring returns the string within stringToSub, beginning at the
                1-based index     startIndex, and consisting of length characters. If length is
                ommitted, the     substring returned starts at startIndex and continues to the end
                of stringToSub.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="stringToSub"/>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="startIndex"/>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="length"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- TODO: Trimming, Padding, Replicating, Insert, Upper, Lower, IsDigit, IsLetter, IsWhitespace? 
	These operators are not primitive, but they are very useful shorthands. Do we want to leave them out for now? (CREF doesn't actually have any of these, and hasn't needed them so far...)
	-->
    <!-- Temporal Operators -->
    <xs:simpleType name="DateGranularity">
        <xs:annotation>
            <xs:documentation>     DateGranularity specifies the granularities available for
                temporal operations     such as DateAdd, DateDiff, and DatePart.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="Year"/>
            <xs:enumeration value="Month"/>
            <xs:enumeration value="Week"/>
            <xs:enumeration value="Day"/>
            <xs:enumeration value="Hour"/>
            <xs:enumeration value="Minute"/>
            <xs:enumeration value="Second"/>
            <xs:enumeration value="Millisecond"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="DateAdd">
        <xs:annotation>
            <xs:documentation>     DateAdd adds numberOfPeriods date periods of the specified
                granularity to the     given date.     Note that this is different than adding an
                Interval to a date time, because for     operations on granularities such as month
                and year, the interval is not well-defined     due to varying month and year
                lengths. As a result, DateAdd is used to provide     well-defined and consistent
                semantics for date arithmetic involving months and years.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="date"
                        type="Expression"/>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="granularity"
                        type="Expression"/>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="numberOfPeriods"
                        type="Expression"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!--Example
	<operand xsi:Type="DateAdd">
		<date xsi:Type="Property" path="BirthDate"/>
		<granularity xsi:Type="Value" valueType="DateGranularity" value="Month"/>
		<numberOfPeriods xsi:Type="Value" valueType="xs:int" value="-6"/>
	</operand>
	-->
    <xs:complexType name="DateDiff">
        <xs:annotation>
            <xs:documentation>     DateDiff returns the number of granularity boundaries occurring
                between     startDate and endDate.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="startDate"
                        type="Expression"/>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="endDate"
                        type="Expression"/>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="granularity"
                        type="Expression"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="DatePart">
        <xs:annotation>
            <xs:documentation>     DatePart returns the granularity component of the given date.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="date"
                        type="Expression"/>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="granularity"
                        type="Expression"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Today">
        <xs:annotation>
            <xs:documentation>     Returns the date (with no time component) of the start timestamp
                associated with     the evaluation request. See the Now operator for more
                information on the rationale     for defining the Today operator in this way.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Now">
        <xs:annotation>
            <xs:documentation>     Returns the date and time of the start timestamp associated with
                the     evaluation request. Now is defined in this way for two reasons:     1) The
                operation will always return the same value within any given evaluation,
                ensuring that the result of an expression containing Now will always return the
                same result.     2) The operation will return the timestamp associated with the
                evaluation      request, allowing the evaluation to be performed with the same
                timezone     information as the data delivered with the evaluation request.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Date">
        <xs:annotation>
            <xs:documentation>     Constructs a date/time value from the given components.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="year"
                        type="xs:int"/>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="month"
                        type="xs:int"/>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="day"
                        type="xs:int"/>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="hour"
                        type="xs:int"/>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="minute"
                        type="xs:int"/>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="second"
                        type="xs:int"/>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="millisecond"
                        type="xs:double"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- Rendered unnecessary by the Interval selector
	<xs:complexType name="DateRange">
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="expression" type="Expression"
						minOccurs="2" maxOccurs="2" />
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType-->
    <!-- Rendered unnecessary by the Interval selector and DateAdd operator
	<xs:complexType name="DateRangeWithin">
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="expression" type="Expression"
						minOccurs="0" maxOccurs="2" />
				</xs:sequence>
				<xs:attribute name="granularity" type="DateGranularity" />
				<xs:attribute name="numberOfPeriods" type="xs:int" />
			</xs:extension>
		</xs:complexContent>
	</xs:complexType-->
    <!-- Interval Operators -->
    <!-- Equal (already defined) -->
    <!-- NotEqual (already defined) -->
    <xs:complexType name="Contains">
        <xs:annotation>
            <xs:documentation>     Returns true if the given source contains the given element.
                There are four overloads of this operator:      List, T : The type of T must be the
                same as the element type of the list.      List, List : The element type of both
                lists must be the same.      Interval, T : The type of T must be the same as the
                point type of the interval.      Interval, Interval : The point type of both
                intervals must be the same.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="source"
                        type="Expression"/>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="element"
                        type="Expression"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Within">
        <xs:annotation>
            <xs:documentation>     Returns true if the given element is in the given interval.
                There are two overloads of this operator:      T, Interval : The type of T must be
                the same as the point type of the interval.      Interval, Interval : The point type
                of both intervals must be the same.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="element"
                        type="Expression"/>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="interval"
                        type="Expression"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="ProperContains">
        <xs:annotation>
            <xs:documentation>     Returns true if the first operand contains the second, and is
                strictly larger.     There are two overloads of this operator:      List, List : The
                element type of both lists must be the same.      Interval, Interval : The point
                type of both intervals must be the same.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="BinaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="ProperIn">
        <xs:annotation>
            <xs:documentation>     Returns true if the first operand is in the second, and is
                strictly smaller.     There are two overloads of this operator:      List, List :
                The element type of both lists must be the same.      Interval, Interval : The point
                type of both intervals must be the same.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="BinaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Before">
        <xs:annotation>
            <xs:documentation>     Returns true if the first interval ends before the second one
                starts.     In other words, if the ending point of the first interval is less than
                the starting point of the second interval.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="BinaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="After">
        <xs:annotation>
            <xs:documentation>     Returns true if the first interval starts after the second one
                ends.     In other words, if the starting point of the first interval is greater
                than the ending point of the second interval.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="BinaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Meets">
        <xs:annotation>
            <xs:documentation>     Returns true if the first interval ends on the starting point of
                the second,     or if the first interval starts on the ending point of the second.
                In other     words, if the ending point of the first interval is equal to the
                starting     point of the second, or if the starting point of the first interval is
                equal to the ending point of the second.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="BinaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Overlaps">
        <xs:annotation>
            <xs:documentation>     Returns true if the first interval overlaps the second. In other
                words, if the ending point of the first interval is greater than     or equal to the
                starting point of the second interval, or if the     starting point of the first
                interval is less than or equal to     the ending point of the second interval.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="BinaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Union">
        <xs:annotation>
            <xs:documentation>     Returns the union of the operands.     This operator has two
                overloads:      List      Interval      For the list overload, this operator returns
                a list with all     elements from all operands.      For the interval overload, this
                operator returns the interval     that starts at the earliest starting point in the
                operands, and     ends at the latest starting point in the operands. Note that if
                the operands do not overlap, this operator returns null.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="NaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Intersect">
        <xs:annotation>
            <xs:documentation>     Returns the intersection of the operands.     This operator has
                two overloads:      List      Interval      For the list overload, this operator
                returns a list with     the elements that appear in the lists.      For the interval
                overload, this operator returns the interval     that defines the overlapping
                portion of the operands. Note that     if the operands do not overlap, this operator
                returns null.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="NaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Difference">
        <xs:annotation>
            <xs:documentation>     Returns the difference of the two operands.     This operator has
                two overloads:      List, List      Interval, Interval      For the list overload,
                this operator returns a list with     the elements that appear in the first operand,
                that do not     appear in the second operand.      For the interval overload, this
                operator returns the portion     of the first interval that does not overlap with
                the second.     Note that if the operands do not overlap, or if the second
                operand is completely contained within the first, this operator     returns null.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="BinaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <!-- Length: Already defined in string operators -->
    <xs:complexType name="Begin">
        <xs:annotation>
            <xs:documentation>     Returns the starting point of the interval operand.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="UnaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="End">
        <xs:annotation>
            <xs:documentation>     Returns the ending point of the interval operand.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="UnaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <!-- List/Set Operators -->
    <xs:complexType name="IsEmpty">
        <xs:annotation>
            <xs:documentation>     Returns true if the list contains no elements.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="UnaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="IsNotEmpty">
        <xs:annotation>
            <xs:documentation>     Returns true if the list contains any elements.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="UnaryExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <!-- Union (already defined) -->
    <!-- Intersect (already defined) -->
    <!-- Difference (already defined) -->
    <xs:complexType name="Filter">
        <xs:annotation>
            <xs:documentation>     The filter expression returns a list with only those elements
                in the source list for which the condition element evaluates     to true.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="source"
                        type="Expression"/>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="condition"
                        type="Expression"/>
                </xs:sequence>
                <xs:attribute name="scope" type="xs:string" use="optional"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- Equal (already defined) -->
    <!-- NotEqual (already defined) -->
    <!-- Indexer (already defined) -->
    <xs:complexType name="IndexOf">
        <xs:annotation>
            <xs:documentation>     IndexOf returns the 1-based index of the given element in the
                given source list.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="source"
                        type="Expression"/>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="element"
                        type="Expression"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- Contains (already defined) -->
    <!-- In -->
    <xs:complexType name="In">
        <xs:annotation>
            <xs:documentation>     Returns true if the given element is in the source element.
                There are two overloads of this operator:      T, List : The type of T must be the
                same as the element type of the list.      List, List : The element type of both
                lists must be the same.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="element"
                        type="Expression"/>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="collection"
                        type="Expression"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- ProperContains (already defined) -->
    <!-- ProperIn (already defined) -->
    <xs:complexType name="Sort">
        <xs:annotation>
            <xs:documentation>     Returns a list with all the elements in source, sorted by the
                given orderBy.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" name="source" type="Expression"/>
                </xs:sequence>
                <xs:attribute name="orderBy" type="xs:string" use="required"/>
            </xs:extension>
            <!-- TODO: Model ordering more explicitly? Multi-column sort? Ascending/Descending? -->
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="ForEach">
        <xs:annotation>
            <xs:documentation>     The ForEach expression iterates over the list of elements     in
                the source element, and returns a list with the same     number of elements, where
                each element in the new list is     the result of evaluating the element expression
                for     each element in the source list.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="source"
                        type="Expression"/>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="element"
                        type="Expression"/>
                </xs:sequence>
                <xs:attribute name="scope" type="xs:string" use="optional"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Distinct">
        <xs:annotation>
            <xs:documentation>     The Distinct operator takes a list of elements and returns a list
                containing     only the unique elements within the input. For example, given the
                list of     integers { 1, 1, 1, 2, 2, 3, 4, 4 }, the result of Distinct would be {
                1, 2, 3, 4 }.          The operator uses equality comparison semantics as defined in
                the Equal     operator.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" name="source" type="Expression"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Current">
        <xs:annotation>
            <xs:documentation>     The Current expression returns the value of the object
                currently in scope. For example, within an ForEach     expression, this returns the
                current element being     considered in the iteration.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:attribute name="scope" type="xs:string" use="optional"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- Aggregate Operators -->
    <!-- TODO: Support grouping? -->
    <xs:complexType abstract="true" name="AggregateExpression">
        <xs:annotation>
            <xs:documentation>     Aggregate expressions perform operations on lists of data,
                either directly on a list of scalars, or indirectly on a      list of objects, with
                a reference to a property present      on each object in the list.      Aggregate
                expressions deal with missing information by      excluding missing values from
                consideration before performing      the aggregated operation. For example, in a Sum
                over Dose, any      instance of Medication with no value for Dose would be ignored.
                An aggregate operation performed over an empty list is defined      to return null,
                except as noted in the documentation for each     operator (Count, AllTrue, and
                AnyTrue are the exceptions).    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="1" name="source"
                        type="Expression"/>
                </xs:sequence>
                <xs:attribute name="path" type="xs:string" use="optional"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Count">
        <xs:annotation>
            <xs:documentation>     Returns the number of non-null elements in the source.      If a
                path is specified, the count returns the number of     elements that have a value
                for the property specified by the path.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="AggregateExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Sum">
        <xs:annotation>
            <xs:documentation>     Returns the sum of non-null elements in the source.      If a
                path is specified, elements with no value for the     property specified by the path
                are ignored.      If source contains no non-null elements, null is returned.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="AggregateExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Min">
        <xs:annotation>
            <xs:documentation>     Returns the minimum element in the source.      If a path is
                specified, elements with no value for the     property specified by the path are
                ignored.          If source contains no non-null elements, null is returned.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="AggregateExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Max">
        <xs:annotation>
            <xs:documentation>     Returns the maximum element in the source.      If a path is
                specified, elements with no value for the     property specified by the path are
                ignored.          If source contains no non-null elements, null is returned.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="AggregateExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="Avg">
        <xs:annotation>
            <xs:documentation>     Returns the average of the elements in source.      If a path is
                specified, elements with no value for the     property specified by the path are
                ignored.          If source contains no non-null elements, null is returned.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="AggregateExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="AllTrue">
        <xs:annotation>
            <xs:documentation>     Returns true if all the elements in source are true.      If a
                path is specified, elements with no value for the     property specified by the path
                are ignored.          If source contains no non-null elements, true is returned.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="AggregateExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="AnyTrue">
        <xs:annotation>
            <xs:documentation>     Returns true if any element in source is true.      If a path is
                specified, elements with no value for the     property specified by the path are
                ignored.          If source contains no non-null elements, false is returned.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="AggregateExpression"/>
        </xs:complexContent>
    </xs:complexType>
    <!-- Data Operators -->
    <xs:complexType name="Property">
        <xs:annotation>
            <xs:documentation>     Returns the value of the property on source specified by the
                path attribute.      If the path attribute contains qualifiers, each qualifier is
                traversed to obtain the actual value.      If a scope is specified, the name is used
                to resolve the scope     in which the path will be resolved. Scopes can be named by
                operators     such as Filter and ForEach.          Property expressions can also be
                used to access the individual points     and open indicators for interval types
                using the property names begin,     end, beginOpen, and endOpen.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="source"
                        type="Expression"/>
                </xs:sequence>
                <xs:attribute name="path" type="xs:string" use="required"/>
                <xs:attribute name="scope" type="xs:string" use="optional"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:annotation>
        <xs:documentation>    This file defines the RequestBase extensions that introduce clinically
            relevant dependencies such as terminology, relevant time, and value set considerations.
        </xs:documentation>
    </xs:annotation>
    <xs:annotation>
        <xs:documentation>    This file defines additional expressions that provide syntactic
            short-hands for literals for each of the base data types.   </xs:documentation>
    </xs:annotation>
    <!--xs:include schemaLocation="base.xsd"/-->
    <!-- 
		AD - Address : ANY
			use : set_PostalAddressUse
			part : List<ADXP>
	-->
    <xs:complexType name="AddressLiteral">
        <xs:annotation>
            <xs:documentation>     Returns a value of type AD with the given attributes.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="unbounded" name="part" type="dt:ADXP"/>
                </xs:sequence>
                <xs:attribute name="use" type="dt:set_PostalAddressUse" use="optional"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!--
		BL - Boolean : ANY
			value : xs:boolean
	-->
    <xs:complexType name="BooleanLiteral">
        <xs:annotation>
            <xs:documentation>     Returns a value of type BL with the given attributes.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:attribute name="value" type="xs:boolean" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!--
		CD - Code : ANY
			code : Code
			codeSystem : Uid
			codeSystemName : xs:string
			displayName : xs:string
			originalText : xs:string
	-->
    <xs:complexType name="CodeLiteral">
        <xs:annotation>
            <xs:documentation>     Returns a value of type CD with the given attributes.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:attribute name="codeSystem" type="dt:Uid" use="required"/>
                <xs:attribute name="code" type="dt:Code" use="required"/>
                <xs:attribute name="codeSystemName" type="xs:string" use="optional"/>
                <xs:attribute name="displayName" type="xs:string" use="optional"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!--
		CO - CodedOrdinal : ANY
			code : CD
			value : Decimal
	-->
    <xs:complexType name="CodedOrdinalLiteral">
        <xs:annotation>
            <xs:documentation>     Returns a value of type CO with the given attributes.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:attribute name="codeSystem" type="dt:Uid" use="required"/>
                <xs:attribute name="code" type="dt:Code" use="required"/>
                <xs:attribute name="codeSystemName" type="xs:string" use="optional"/>
                <xs:attribute name="displayName" type="xs:string" use="optional"/>
                <xs:attribute name="value" type="dt:Decimal" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!--
		CS - CodeSimple : ANY
			code : xs:string
	-->
    <xs:complexType name="SimpleCodeLiteral">
        <xs:annotation>
            <xs:documentation>     Returns a value of type CS with the given attributes.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:attribute name="code" type="xs:string" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!--
		EN - EntityName : ANY
			use : set_EntityNameUse
			part : List<ENXP>
	-->
    <xs:complexType name="EntityNameLiteral">
        <xs:annotation>
            <xs:documentation>     Returns a value of type EN with the given attributes.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="unbounded" name="part" type="dt:ENXP"/>
                </xs:sequence>
                <xs:attribute name="use" type="dt:set_EntityNameUse" use="optional"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!--
		II - Identifier : ANY
			root : Uid
			extension : xs:string
	-->
    <xs:complexType name="IdentifierLiteral">
        <xs:annotation>
            <xs:documentation>     Returns a value of type II with the given attributes.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:attribute name="root" type="dt:Uid" use="required"/>
                <xs:attribute name="extension" type="xs:string" use="optional"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!--
		INT - Integer : QTY
			value : xs:int
	-->
    <xs:complexType name="IntegerLiteral">
        <xs:annotation>
            <xs:documentation>     Returns a value of type INT with the given attributes.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:attribute name="value" type="xs:int" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!--
		IVL_INT - IntegerInterval : ANY
			low : xs:int
			high : xs:int
			lowClosed : xs:boolean
			highClosed : xs:boolean
	-->
    <xs:complexType name="IntegerIntervalLiteral">
        <xs:annotation>
            <xs:documentation>     Returns a value of type IVL_INT with the given attributes.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:attribute name="low" type="xs:int"/>
                <xs:attribute name="high" type="xs:int"/>
                <xs:attribute name="lowClosed" type="xs:boolean" use="optional"/>
                <xs:attribute name="highClosed" type="xs:boolean" use="optional"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!--
		IVL_PQ - PhysicalQuantityInterval : ANY
			ATTR_PQ_LOW
			ATTR_PQ_HIGH
			lowClosed : xs:boolean
			highClosed : xs:boolean
	-->
    <xs:complexType name="PhysicalQuantityIntervalLiteral">
        <xs:annotation>
            <xs:documentation>     Returns a value of type IVL_PQ with the given attributes.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="low" type="dt:PQ"/>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="high"
                        type="dt:PQ"/>
                </xs:sequence>
                <xs:attribute name="lowClosed" type="xs:boolean" use="optional"/>
                <xs:attribute name="highClosed" type="xs:boolean" use="optional"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!--
		IVL_QTY - QuantityInterval : ANY
			low : QTY
			high : QTY
			lowClosed : xs:boolean
			highClosed : xs:boolean
	-->
    <xs:complexType name="QuantityIntervalLiteral">
        <xs:annotation>
            <xs:documentation>     Returns a value of type IVL_QTY with the given attributes.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" minOccurs="0" name="low" type="dt:QTY"/>
                    <xs:element form="qualified" minOccurs="0" name="high" type="dt:QTY"/>
                </xs:sequence>
                <xs:attribute name="lowClosed" type="xs:boolean" use="optional"/>
                <xs:attribute name="highClosed" type="xs:boolean" use="optional"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!--
		IVL_REAL - RealInterval : ANY
			low : Decimal
			high : Decimal
			lowClosed : xs:boolean
			highClosed : xs:boolean
	-->
    <xs:complexType name="RealIntervalLiteral">
        <xs:annotation>
            <xs:documentation>     Returns a value of type IVL_REAL with the given attributes.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:attribute name="low" type="dt:Decimal"/>
                <xs:attribute name="high" type="dt:Decimal"/>
                <xs:attribute name="lowClosed" type="xs:boolean" use="optional"/>
                <xs:attribute name="highClosed" type="xs:boolean" use="optional"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!--
		IVL_TS - TimestampInterval : ANY
			ATTR_TS_LOW
			ATTR_TSHIGH
			lowClosed : xs:boolean
			highClosed : xs:boolean
	-->
    <xs:complexType name="TimestampIntervalLiteral">
        <xs:annotation>
            <xs:documentation>     Returns a value of type IVL_TS with the given attributes.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="low" type="dt:TS"/>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="high"
                        type="dt:TS"/>
                </xs:sequence>
                <xs:attribute name="lowClosed" type="xs:boolean" use="optional"/>
                <xs:attribute name="highClosed" type="xs:boolean" use="optional"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!--
		PQ - PhysicalQuantity : QTY
			ATTR_PQ
	-->
    <xs:complexType name="PhysicalQuantityLiteral">
        <xs:annotation>
            <xs:documentation>     Returns a value of type PQ with the given attributes.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:attribute name="value" type="dt:Decimal" use="required"/>
                <xs:attribute name="unit" type="dt:Code" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!--
		REAL - Real : QTY
			value : Decimal
	-->
    <xs:complexType name="RealLiteral">
        <xs:annotation>
            <xs:documentation>     Returns a value of type Real with the given attributes.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:attribute name="value" type="dt:Decimal" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!--
		RTO - Ratio : QTY
			numerator : QTY
			denominator : QTY
	-->
    <xs:complexType name="RatioLiteral">
        <xs:annotation>
            <xs:documentation>     Returns a value of type RTO with the given numerator and
                denominator.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" name="numerator" type="dt:QTY">
                        <xs:annotation>
                            <xs:documentation>The quantity that is being divided in the
                                ratio</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element form="qualified" name="denominator" type="dt:QTY">
                        <xs:annotation>
                            <xs:documentation>The quantity that divides the numerator in the ratio.
                                The denominator SHALL not be zero.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!--
		RTO_INT - Ratio : QTY
			ATTR_RTO_INT
	<xs:complexType name="IntegerRatioLiteral">
		<xs:annotation>
			<xs:documentation>
				Returns a value of type RTO_INT with the given attributes.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="numerator" type="dt:INT" minOccurs="1" maxOccurs="1"/>
					<xs:element name="denominator" type="dt:INT" minOccurs="1" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	-->
    <!--
		RTO_PQ - Ratio : QTY
			ATTR_RTO_PQ
	<xs:complexType name="PhysicalQuantityRatioLiteral">
		<xs:annotation>
			<xs:documentation>
				Returns a value of type RTO_PQ with the given attributes.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="numerator" type="dt:PQ" minOccurs="1" maxOccurs="1"/>
					<xs:element name="denominator" type="dt:PQ" minOccurs="1" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	-->
    <!--
		ST - String : ANY
			value : xs:string
	-->
    <xs:complexType name="StringLiteral">
        <xs:annotation>
            <xs:documentation>     Returns a value of type ST with the given attributes.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:attribute name="value" type="xs:string" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!--
		TEL - URL : ANY
			value : xs:anyURI
			use : set_TelecommunicationAddressUse
			capabilities : set_TelecommunicationCapability
			useablePeriodOriginalText : xs:string
	-->
    <xs:complexType name="UrlLiteral">
        <xs:annotation>
            <xs:documentation>     Returns a value of type TEL with the given attributes.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:attribute name="value" type="xs:anyURI" use="required"/>
                <xs:attribute name="use" type="dt:set_TelecommunicationAddressUse" use="optional"/>
                <xs:attribute name="capabilities" type="dt:set_TelecommunicationCapability"
                    use="optional"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!--
		TS - Timestamp : QTY
			value : xs:string (regex restricted)
	-->
    <xs:complexType name="TimestampLiteral">
        <xs:annotation>
            <xs:documentation>     Returns a value of type TS with the given attributes.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:attribute name="value" type="dt:TimeStamp" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!--
		PIVL_TS
			phase : IVL_TS
			period : PQ
			frequency : RTO
			count : INT
			alignment : CalendarCycle
			isFlexible : xs:boolean
	-->
    <xs:complexType name="PeriodLiteral">
        <xs:annotation>
            <xs:documentation>     Returns a value of type PIVL_TS with the given attributes.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" minOccurs="0" name="phase" type="dt:IVL_TS">
                        <xs:annotation>
                            <xs:documentation>A prototype of the repeating interval, specifying the
                                duration of each occurrence and anchors the PIVL sequence at a
                                certain point in time. phase also marks the anchor point in time for
                                the entire series of periodically recurring intervals. If count is
                                null or nullFlavored, the recurrence of a PIVL has no beginning or
                                ending, but is infinite in both future and past.   The width of the
                                phase SHALL be less than or equal to the period</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element form="qualified" minOccurs="0" name="period" type="dt:PQ">
                        <xs:annotation>
                            <xs:documentation>A time duration specified as a reciprocal measure of
                                the frequency at which the PIVL repeats.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element form="qualified" minOccurs="0" name="frequency" type="dt:RTO">
                        <xs:annotation>
                            <xs:documentation>The number of times the PIVL repeats (numerator)
                                within a specified time-period (denominator). The numerator is an
                                integer, and the denominator is a PQ.TIME.  Only one of period and
                                frequency should be specified. The form chosen should be the form
                                that most naturally conveys the idea to humans. i.e. Every 10 mins
                                (period) or twice a day (frequency).</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element form="qualified" minOccurs="0" name="count" type="dt:INT">
                        <xs:annotation>
                            <xs:documentation>The number of times the period repeats in total. If
                                count is null, then the period repeats indefinitely both before and
                                after the anchor implicit in the phase.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                </xs:sequence>
                <xs:attribute name="alignment" type="dt:CalendarCycle" use="optional"/>
                <xs:attribute name="isFlexible" type="xs:boolean" use="optional">
                    <xs:annotation>
                        <xs:documentation>Indicates whether the exact timing is up to the party
                            executing the schedule e.g., to distinguish "every 8 hours" from "3
                            times a day".  Note: this is sometimes referred to as "institution
                            specified timing".</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
            <!--  changed from bl to xs:boolean since bl was removed as a type 
					Aziz Boxwala 
				 -->
        </xs:complexContent>
    </xs:complexType>
    <xs:annotation>
        <xs:documentation>    This file defines the EventType enumeration.   </xs:documentation>
    </xs:annotation>
    <xs:annotation>
        <xs:documentation>    This file allows organizations to extend the enumeration EventType.
        </xs:documentation>
    </xs:annotation>
    <xs:annotation>
        <xs:documentation>    This file defines the core values available within the EventType
            enumeration.   </xs:documentation>
    </xs:annotation>
    <xs:simpleType name="EventTypeCore">
        <xs:restriction base="xs:string">
            <xs:enumeration value="DataEvent">
                <xs:annotation>
                    <xs:documentation>An event in which a data item is created, removed, updated, or
                        accessed.      Expression is expected to be an ExpressionRef       that
                        references an ExpressionDef in ExternalData that contains a       Request
                        with a triggerType attribute specified.      </xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="PeriodicEvent">
                <xs:annotation>
                    <xs:documentation>A time-based event which occurs at the specified period.
                        Expression is expected to be a Period literal       expression specifying
                        the period on which the       event should be repeated
                    </xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="EventTypeExt">
        <xs:restriction base="EventTypeCore"/>
    </xs:simpleType>
    <xs:simpleType name="EventType">
        <xs:annotation>
            <xs:documentation>An enumeration of event types. Events occur external to the artifact
                that can be used as a trigger to the artifact.</xs:documentation>
        </xs:annotation>
        <xs:union memberTypes="EventTypeCore EventTypeExt"/>
    </xs:simpleType>
    <xs:annotation>
        <xs:documentation>    This file defines the DataEventType enumeration.   </xs:documentation>
    </xs:annotation>
    <xs:annotation>
        <xs:documentation>    This file allows organizations to extend the enumeration
            DataEventType.    </xs:documentation>
    </xs:annotation>
    <xs:annotation>
        <xs:documentation>    This file defines the core values available within the DataEventType
            enumeration.   </xs:documentation>
    </xs:annotation>
    <xs:simpleType name="DataEventTypeCore">
        <xs:restriction base="xs:string">
            <xs:enumeration value="DataElementAdded"/>
            <xs:enumeration value="DataElementModified"/>
            <xs:enumeration value="DataElementRemoved"/>
            <xs:enumeration value="DataElementAccessed"/>
            <xs:enumeration value="DataElementAccessEnded"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="DataEventTypeExt">
        <xs:restriction base="DataEventTypeCore"/>
    </xs:simpleType>
    <xs:simpleType name="DataEventType">
        <xs:annotation>
            <xs:documentation>Enumeration of types of events related to access, creation, removal,
                or update of data.</xs:documentation>
        </xs:annotation>
        <xs:union memberTypes="DataEventTypeCore DataEventTypeExt"/>
    </xs:simpleType>
    <xs:simpleType name="RequestCardinality">
        <xs:annotation>
            <xs:documentation>     RequestCardinality defines the expected cardinality of the
                request, single     or multiple.      If a request results in a cardinality higher
                than expected, a run-time     exception should be thrown.    </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="Single"/>
            <xs:enumeration value="Multiple"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType abstract="true" name="RequestBase">
        <xs:annotation>
            <xs:documentation>     The request expression defines the data that will be used by the
                artifact.      The result of a request is defined to return the same data for
                subsequent invocations     within the same evaluation request. This means in
                particular that patient data updates made     during the evaluation request are not
                visible to the artifact. In effect, the patient data     is a snapshot of the data
                as of the start of the evaluation. This ensures strict deterministic     and
                functional behavior of the artifact, and allows the implementation engine freedom to
                cache intermediate results in order to improve performance.      The dataType
                attribute specifies the type of clinical data being requested.      The templateId
                attribute specifies an optional template to be used. If specified, the request
                is defined to return only objects that conform to the template.      The idProperty
                attribute specifies which property of the model contains the Id for the clinical
                statement.      The triggerType attribute optionally specifies whether this request
                should only include     data that was accessed or updated as a result of some event
                that is triggering the evaluation     of the artifact. This attribute is only valid
                on a request that is specified as the request     for a data changed event trigger.
                The isInitial attribute determines whether the request is part of the initial data
                requirements     for the artifact.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="timeOffset"
                        type="Expression"/>
                </xs:sequence>
                <xs:attribute name="scope" type="xs:string" use="optional"/>
                <xs:attribute name="cardinality" type="RequestCardinality" use="required"/>
                <xs:attribute name="dataType" type="xs:QName" use="required"/>
                <xs:attribute name="templateId" type="xs:string" use="optional"/>
                <xs:attribute name="idProperty" type="xs:string" use="optional"/>
                <xs:attribute name="triggerType" type="DataEventType" use="optional"/>
                <xs:attribute default="true" name="isInitial" type="xs:boolean" use="optional"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="DataRequest">
        <xs:complexContent>
            <xs:extension base="RequestBase"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="ClinicalRequest">
        <xs:annotation>
            <xs:documentation>     The clinical request expression defines clinical data that will
                be used by the artifact.      The codes element optionally allows a set of codes to
                be provided. The codes list restricts      the set of clinical statements returned
                to only those clinical statements that matched some      code in the set.      The
                dateRange element optionally allows a date range to be provided. The clinical
                statements      returned would be only those clinical statements whose date fell
                within the range specified.      The codeProperty attribute optionally specifies
                which property of the model contains the Code      or Codes for the clinical
                statement.      The dateProperty attribute optionally specifies which property of
                the model contains the      clinically relevant date for the clinical statement.
                These properties (codeProperty and dateProperty) could potentially be specified
                elsewhere,      rather than on each Request expression, but allowing them at the
                request expression level      gives the most flexibility.      The useValueSets
                attribute determines whether references to value sets in the Codes element      will
                be expanded, or left as value set references for the purposes of communicating
                across      the data boundary.      The useSubsumption attribute determines whether
                subsumption should be used to determine     whether or not a given data item should
                be included in the result.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="RequestBase">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="codes"
                        type="Expression"/>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="dateRange"
                        type="Expression"/>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="subject"
                        type="Expression"/>
                </xs:sequence>
                <xs:attribute name="codeProperty" type="xs:string" use="optional"/>
                <xs:attribute name="dateProperty" type="xs:string" use="optional"/>
                <xs:attribute name="subjectProperty" type="xs:string" use="optional"/>
                <xs:attribute default="false" name="useValueSets" type="xs:boolean" use="optional"/>
                <xs:attribute default="false" name="useSubsumption" type="xs:boolean" use="optional"
                />
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- 
		TODO: This needs to be expanded, we need to know how to reference a value set.
		id and version is assumed for now, but we need a clear mechanism for referring
		to a value set.

		There is some discussion about using the CTS HL7 standard to inform the design
		of these operators.
	-->
    <xs:complexType name="ValueSet">
        <xs:annotation>
            <xs:documentation>     Returns a list of codes whose elements are defined by the
                given value set authority for the given value set id and version.      If version is
                an asterisk (*), the current version of the value     set is returned.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:attribute name="id" type="xs:string" use="required"/>
                <xs:attribute name="version" type="xs:string" use="optional"/>
                <xs:attribute name="authority" type="xs:string" use="optional"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="InValueSet">
        <xs:annotation>
            <xs:documentation>     Returns true if the given code, or list of codes, is in the
                given value set.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="UnaryExpression">
                <xs:attribute name="id" type="xs:string" use="required"/>
                <xs:attribute name="version" type="xs:string" use="optional"/>
                <xs:attribute name="authority" type="xs:string" use="optional"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- Subsumption Operators -->
    <xs:complexType name="Subsumes">
        <xs:annotation>
            <xs:documentation>     This operator returns true if the operands were of the same code
                system,      and the ancestor operand subsumed the descendant operand in the
                hierarchy of      the code system. If the codes are the same code, the operator
                returns true.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="ancestor"
                        type="Expression"/>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="descendent"
                        type="Expression"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="SetSubsumes">
        <xs:annotation>
            <xs:documentation>     This operator returns the list of descendants that were subsumed
                by some code      in the list of ancestors.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Expression">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="ancestors"
                        type="Expression"/>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="descendents"
                        type="Expression"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- TODO: SubsumedSet operator? Given a code, returns the set of codes for which Subsumes would return true? -->
    <xs:annotation>
        <xs:documentation>    This file defines the BehaviorType enumeration.   </xs:documentation>
    </xs:annotation>
    <xs:annotation>
        <xs:documentation>    This file allows organizations to extend the enumeration BehaviorType.
        </xs:documentation>
    </xs:annotation>
    <xs:annotation>
        <xs:documentation>    This file defines the core values available within the BehaviorType
            enumeration.   </xs:documentation>
    </xs:annotation>
    <xs:simpleType name="GroupSelectionBehaviorTypeCore">
        <xs:restriction base="xs:string">
            <xs:enumeration value="Any">
                <xs:annotation>
                    <xs:documentation>Any number of the items in the group may be chosen, from zero
                        to all.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="All">
                <xs:annotation>
                    <xs:documentation>All the items in the group must be selected as a single
                        unit.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="AllOrNone">
                <xs:annotation>
                    <xs:documentation>All the items in the group are meant to be chosen as a single
                        unit:  either all must be selected by the end user, or none may be
                        selected.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="ExactlyOne">
                <xs:annotation>
                    <xs:documentation>The end user must choose one and only one of the selectable
                        items in the group.  The user may not choose none of the items in the
                        group.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="AtMostOne">
                <xs:annotation>
                    <xs:documentation>The end user may choose zero or at most one of the items in
                        the group.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="OneOrMore">
                <xs:annotation>
                    <xs:documentation>The end user must choose a minimum of one, and as many
                        additional as desired.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="GroupOrganizationBehaviorTypeCore">
        <xs:restriction base="xs:string">
            <xs:enumeration value="VisualGroup">
                <xs:annotation>
                    <xs:documentation>Any group marked with this behavior should be displayed as a
                        visual group to the end user. </xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="LogicalGroup">
                <xs:annotation>
                    <xs:documentation>A group with this behavior logically groups its sub-elements,
                        and may be shown as a visual group to the end user, but it is not required
                        to do so.  </xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="SentenceGroup">
                <xs:annotation>
                    <xs:documentation>A group of related alternative actions is a sentence group if
                        the item referenced by the action is the same in all the actions, and each
                        action simply constitutes a different variation on how to specify the
                        details for that item.  For example, two actions that could be in a
                        SentenceGroup are "aspirin, 500 mg, 2 times per day" and "aspirin, 300 mg, 3
                        times per day".  In both cases, aspirin is the item referenced by the
                        action, and the two actions represent two different options for how aspirin
                        might be ordered for the patient.  Note that a SentenceGroup would almost
                        always have an associated selection behavior of "AtMostOne", unless it's a
                        required action, in which case, it would be "ExactlyOne".</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="RequiredBehaviorTypeCore">
        <xs:restriction base="xs:string">
            <xs:enumeration value="Must">
                <xs:annotation>
                    <xs:documentation>An action with this behavior must be included in the actions
                        processed by the end user; the end user may not choose not to include this
                        action.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="Could">
                <xs:annotation>
                    <xs:documentation>An action with this behavior may be included in the set of
                        actions processed by the end user.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="MustUnlessDocumented">
                <xs:annotation>
                    <xs:documentation>An action with this behavior must be included in the set of
                        actions processed by the end user, unless the end user provides
                        documentation as to why the action was not included.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="PrecheckBehaviorTypeCore">
        <xs:restriction base="xs:string">
            <xs:enumeration value="Yes">
                <xs:annotation>
                    <xs:documentation>An action with this behavior is one of the most frequent
                        actions that is, or should be, included by an end user, for the particular
                        context in which the action occurs.  The system displaying the action to the
                        end user should consider "pre-checking" such an action as a convenience for
                        the user.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="No">
                <xs:annotation>
                    <xs:documentation>An action with this behavior is one of the less frequent
                        actions included by the end user, for the particular context in which the
                        action occurs.  The system displaying the actions to the end user would
                        typically not "pre-check" such an action.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="GroupSelectionBehaviorTypeExt">
        <xs:restriction base="GroupSelectionBehaviorTypeCore"/>
    </xs:simpleType>
    <xs:simpleType name="GroupOrganizationBehaviorTypeExt">
        <xs:restriction base="GroupOrganizationBehaviorTypeCore"/>
    </xs:simpleType>
    <xs:simpleType name="RequiredBehaviorTypeExt">
        <xs:restriction base="RequiredBehaviorTypeCore"/>
    </xs:simpleType>
    <xs:simpleType name="PrecheckBehaviorTypeExt">
        <xs:restriction base="PrecheckBehaviorTypeCore"/>
    </xs:simpleType>
    <xs:simpleType name="GroupSelectionBehaviorType">
        <xs:annotation>
            <xs:documentation>Defines selection behavior of a group:  specifies the number of
                selectable items in the group that may be selected by the end user when the items of
                the group are displayed.</xs:documentation>
        </xs:annotation>
        <xs:union memberTypes="GroupSelectionBehaviorTypeCore GroupSelectionBehaviorTypeExt"/>
    </xs:simpleType>
    <xs:simpleType name="GroupOrganizationBehaviorType">
        <xs:annotation>
            <xs:documentation>Defines organization behavior of a group:  gives the reason why the
                items are grouped together.  </xs:documentation>
        </xs:annotation>
        <xs:union memberTypes="GroupOrganizationBehaviorTypeCore GroupOrganizationBehaviorTypeExt"/>
    </xs:simpleType>
    <xs:simpleType name="RequiredBehaviorType">
        <xs:annotation>
            <xs:documentation>Defines requiredness behavior for selecting an action or an action
                group; i.e., whether the action or action group is required or
                optional.</xs:documentation>
        </xs:annotation>
        <xs:union memberTypes="RequiredBehaviorTypeCore RequiredBehaviorTypeExt"/>
    </xs:simpleType>
    <xs:simpleType name="PrecheckBehaviorType">
        <xs:annotation>
            <xs:documentation>Defines selection frequency behavior for an action or group; i.e., for
                most frequently selected items, the end-user system may provide convenience options
                in the UI (such as pre-selection) in order to (1) communicate to the end user what
                the most frequently selected item is, or should, be in a particular context, and (2)
                save the end user time.  </xs:documentation>
        </xs:annotation>
        <xs:union memberTypes="PrecheckBehaviorTypeCore PrecheckBehaviorTypeExt"/>
    </xs:simpleType>
    <xs:annotation>
        <xs:documentation>    This file defines the behaviors used within knowledge documents.
        </xs:documentation>
    </xs:annotation>
    <xs:complexType abstract="true" name="Behavior">
        <xs:annotation>
            <xs:documentation>A behavior may be specified for a specific action or a group of
                actions.   This is the base type for all Behaviors.</xs:documentation>
        </xs:annotation>
        <xs:attribute name="value"/>
    </xs:complexType>
    <xs:complexType name="Behaviors">
        <xs:sequence>
            <xs:element form="qualified" maxOccurs="unbounded" name="behavior" type="Behavior"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="GroupSelectionBehavior">
        <xs:annotation>
            <xs:documentation>For a group of actions, specifies the number of actions that may be
                chosen by an end user.</xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:restriction base="Behavior">
                <xs:attribute name="value" type="GroupSelectionBehaviorType"/>
            </xs:restriction>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="GroupOrganizationBehavior">
        <xs:annotation>
            <xs:documentation>For a group of actions, specifies the organizational intent of the
                grouping.   This is meant to provide a hint to the system which displays the group
                of actions to an end user.  </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:restriction base="Behavior">
                <xs:attribute name="value" type="GroupOrganizationBehaviorType"/>
            </xs:restriction>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="RequiredBehavior">
        <xs:annotation>
            <xs:documentation>For a single action, specifies what level of requiredness is
                associated with the action.</xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:restriction base="Behavior">
                <xs:attribute name="value" type="RequiredBehaviorType"/>
            </xs:restriction>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="PrecheckBehavior">
        <xs:annotation>
            <xs:documentation>For a particular action, specifies how often the action is expected to
                be selected in the particular context of the group containing that action.  In
                general, depending on the group selection behavior, there may be zero, one or more
                actions which are frequently selected.  This setting can serve as a hint to the
                system that displays the action to the end user: some systems will pre-select those
                actions which are (or should be) most frequently selected.</xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:restriction base="Behavior">
                <xs:attribute name="value" type="PrecheckBehaviorType"/>
            </xs:restriction>
        </xs:complexContent>
    </xs:complexType>
    <xs:annotation>
        <xs:documentation>    This file defines the Actor type.   </xs:documentation>
    </xs:annotation>
    <xs:complexType name="Actor">
        <xs:annotation>
            <xs:documentation>An actor is an entity responsible for the execution of an
                action.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element form="qualified" name="actor" type="ExpressionDef">
                <xs:annotation>
                    <xs:documentation>The expression must evaluate to one of the following: 1. CD or
                        a List of CD. In this case, the actor defines the role or roles of entities
                        to execute the action. 2. II or a List of II. In this case, the actor
                        defines entities, such as a provider or a team.      </xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:complexType>
    <xs:annotation>
        <xs:documentation>    This file defines catalog items used to describe questions and
            responses for the documentation template knowledge artifact type.   </xs:documentation>
    </xs:annotation>
    <xs:annotation>
        <xs:documentation>    This file defines the Cardinality enumeration.   </xs:documentation>
    </xs:annotation>
    <xs:simpleType name="Cardinality">
        <xs:annotation>
            <xs:documentation>     Cardinality defines the expected cardinality of an element,
                single     or multiple.    </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="Single"/>
            <xs:enumeration value="Multiple"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:annotation>
        <xs:documentation>    This file defines the RangeConstraintType enumeration.
        </xs:documentation>
    </xs:annotation>
    <xs:annotation>
        <xs:documentation>    This file allows organizations to extend the enumeration
            RangeConstraintType.    </xs:documentation>
    </xs:annotation>
    <xs:annotation>
        <xs:documentation>    This file defines the core values available within the
            RangeCosntraintType enumeration.   </xs:documentation>
    </xs:annotation>
    <xs:simpleType name="RangeConstraintTypeCore">
        <xs:restriction base="xs:string">
            <xs:enumeration value="Minimum">
                <xs:annotation>
                    <xs:documentation>The constraint specifies the lower bound or minimum value of a
                        documentation item value. This constraint type applies to quantitative value
                        types only.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="Maximum">
                <xs:annotation>
                    <xs:documentation>The constraint specifies the upper bound or minimum value of a
                        documentation item value. This constraint type applies to quantitative value
                        types only.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="List">
                <xs:annotation>
                    <xs:documentation>The constraint restricts the value to items from a
                        list.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="Component"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="RangeConstraintTypeExt">
        <xs:restriction base="RangeConstraintTypeCore"/>
    </xs:simpleType>
    <xs:simpleType name="RangeConstraintType">
        <xs:annotation>
            <xs:documentation>The enumeration of different types of range constraints on values.
            </xs:documentation>
        </xs:annotation>
        <xs:union memberTypes="RangeConstraintTypeCore RangeConstraintTypeExt"/>
    </xs:simpleType>
    <xs:annotation>
        <xs:documentation>    This file defines the ValueType enumeration.   </xs:documentation>
    </xs:annotation>
    <xs:annotation>
        <xs:documentation>    This file allows organizations to extend the enumeration ValueType.
        </xs:documentation>
    </xs:annotation>
    <xs:annotation>
        <xs:documentation>    This file defines the core values available within the ValueType
            enumeration.   </xs:documentation>
    </xs:annotation>
    <xs:simpleType name="ValueTypeCore">
        <xs:restriction base="xs:string">
            <xs:enumeration value="Boolean"/>
            <xs:enumeration value="Code"/>
            <xs:enumeration value="CodedOrdinal"/>
            <xs:enumeration value="EntityName"/>
            <xs:enumeration value="Identifier"/>
            <xs:enumeration value="Integer"/>
            <xs:enumeration value="IntegerInterval"/>
            <xs:enumeration value="Period"/>
            <xs:enumeration value="PhysicalQuantity"/>
            <xs:enumeration value="PhysicalQuantityInterval"/>
            <xs:enumeration value="QuantityInterval"/>
            <xs:enumeration value="Ratio"/>
            <xs:enumeration value="Real"/>
            <xs:enumeration value="RealInterval"/>
            <xs:enumeration value="SimpleCode"/>
            <xs:enumeration value="String"/>
            <xs:enumeration value="Timestamp"/>
            <xs:enumeration value="TimestampInterval"/>
            <xs:enumeration value="URL"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ValueTypeExt">
        <xs:restriction base="ValueTypeCore"/>
    </xs:simpleType>
    <xs:simpleType name="ValueType">
        <xs:annotation>
            <xs:documentation>A specification of a constraint on the range of values for an
                item.</xs:documentation>
        </xs:annotation>
        <xs:union memberTypes="ValueTypeCore ValueTypeExt"/>
    </xs:simpleType>
    <xs:element name="itemDefinitions">
        <xs:annotation>
            <xs:documentation>A collection of item definitions</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="item"
                    type="ItemDefinition"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
    <xs:complexType abstract="true" name="ItemDefinition">
        <xs:annotation>
            <xs:documentation>An item definition is the equivalent of an item in     a data
                dictionary or a catalog in an electronic health record
                system.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element form="qualified" minOccurs="0" name="identifier" type="VersionedIdentifier">
                <xs:annotation>
                    <xs:documentation>The identifier for the item.</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="DocumentationItem">
        <xs:annotation>
            <xs:documentation>An item type representing the definition of an     individual item to
                be recorded in a structured clinical document.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ItemDefinition">
                <xs:sequence>
                    <xs:element form="qualified" name="displayText" type="dt:ST">
                        <xs:annotation>
                            <xs:documentation>Brief text or title for this documentation item
                                that is the caption displayed to the user performing the
                                documentation.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="description"
                        type="dt:ST">
                        <xs:annotation>
                            <xs:documentation>A lengthier description of this documentation
                                item that is displayed to the user.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="itemCodes">
                        <xs:annotation>
                            <xs:documentation>A collection of codes for concepts that are the
                                equivalents of this documentation item.</xs:documentation>
                        </xs:annotation>
                        <xs:complexType>
                            <xs:sequence>
                                <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
                                    name="itemCode" type="dt:CD">
                                    <xs:annotation>
                                        <xs:documentation>A code for a concept that is the
                                            equivalent            of this documentation
                                            item.</xs:documentation>
                                    </xs:annotation>
                                </xs:element>
                            </xs:sequence>
                        </xs:complexType>
                    </xs:element>
                    <xs:element form="qualified" name="responseDataType">
                        <xs:annotation>
                            <xs:documentation>The data type of the value or the response that
                                is entered by the user.</xs:documentation>
                        </xs:annotation>
                        <xs:complexType>
                            <xs:attribute name="value" type="ValueType"/>
                        </xs:complexType>
                    </xs:element>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="0"
                        name="responseCardinality">
                        <xs:annotation>
                            <xs:documentation>The number of allowed responses, single or
                                multiple.</xs:documentation>
                        </xs:annotation>
                        <xs:complexType>
                            <xs:attribute name="value" type="Cardinality"/>
                        </xs:complexType>
                    </xs:element>
                    <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
                        name="responseRange" type="RangeConstraint">
                        <xs:annotation>
                            <xs:documentation>The constraints (within the responseDataType)
                                on the values that may be entered by the user</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType abstract="true" name="RangeConstraint">
        <xs:sequence>
            <xs:element form="qualified" name="constraintType">
                <xs:annotation>
                    <xs:documentation>The constraint type defines how the value range       is being
                        constrained. For example, the constraint type may       indicate the lower
                        bound of the range.</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:attribute name="value" type="RangeConstraintType"/>
                </xs:complexType>
            </xs:element>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="ExpressionConstraint">
        <xs:annotation>
            <xs:documentation>A constraint specified in the form of an     expression. The
                constraint type and the constraint expression     combine together to specify the
                full constraint. For example,     the constraint type specifies that the lower bound
                is being specified     and the expression provides the lower bound value.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="RangeConstraint">
                <xs:sequence>
                    <xs:element form="qualified" name="constraint" type="Expression">
                        <xs:annotation>
                            <xs:documentation/>
                        </xs:annotation>
                    </xs:element>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="ListConstraint">
        <xs:annotation>
            <xs:documentation>A constraint specifying that the value is from a     list included
                here.</xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="RangeConstraint">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="unbounded" minOccurs="1" name="item">
                        <xs:annotation>
                            <xs:documentation>An item in the list of possible values
                            </xs:documentation>
                        </xs:annotation>
                        <xs:complexType>
                            <xs:sequence>
                                <xs:element form="qualified" name="value" type="Expression">
                                    <xs:annotation>
                                        <xs:documentation>The value of the item is specified as an
                                            expression. This is the value that could be displayed to
                                            the            user and which forms the recorded value
                                            of the documentation            item.</xs:documentation>
                                    </xs:annotation>
                                </xs:element>
                                <xs:element form="qualified" minOccurs="0" name="codes">
                                    <xs:annotation>
                                        <xs:documentation>A collection of codes that are the
                                            equivalent of this value.</xs:documentation>
                                    </xs:annotation>
                                    <xs:complexType>
                                        <xs:sequence>
                                            <xs:element form="qualified" maxOccurs="unbounded"
                                                minOccurs="0" name="code" type="dt:CD">
                                                <xs:annotation>
                                                  <xs:documentation>An individual code that is the
                                                  equivalent               of this
                                                  value.</xs:documentation>
                                                </xs:annotation>
                                            </xs:element>
                                        </xs:sequence>
                                    </xs:complexType>
                                </xs:element>
                                <xs:element form="qualified" minOccurs="0" name="displayText"
                                    type="dt:ST">
                                    <xs:annotation>
                                        <xs:documentation>Short text label for the list item. When
                                            displayText is present, this is displayed to the user
                                            performing the documentation. In such a case, the value
                                            is            displayed optionally</xs:documentation>
                                    </xs:annotation>
                                </xs:element>
                                <!-- <xs:element name="numericEquivalent" type="xs:decimal" maxOccurs="1" 
									minOccurs="0" > <xs:annotation> <xs:documentation>An equivalent numeric value 
									for the field. This is used when the documentation item is part of a set 
									of items that are used to compute a score</xs:documentation> </xs:annotation></xs:element> -->
                            </xs:sequence>
                        </xs:complexType>
                    </xs:element>
                </xs:sequence>
                <xs:attribute name="strictSelection" type="xs:boolean">
                    <xs:annotation>
                        <xs:documentation>If strictSelection is set to true, the value
                            entered by the user must be        an item from the list. If this is set
                            to false, the value may not be restricted to this list.
                        </xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:annotation>
        <xs:documentation>    This file defines the condition components used in knowledge
            artifacts.   </xs:documentation>
    </xs:annotation>
    <xs:annotation>
        <xs:documentation>    This file defines the ConditionRoleType enumeration.
        </xs:documentation>
    </xs:annotation>
    <xs:annotation>
        <xs:documentation>    This file allows organizations to extend the enumeration
            ConditionRoleType.    </xs:documentation>
    </xs:annotation>
    <xs:annotation>
        <xs:documentation>    This file defines the core values available within the
            ConditionRoleType enumeration.   </xs:documentation>
    </xs:annotation>
    <xs:simpleType name="ConditionRoleTypeCore">
        <xs:restriction base="xs:string">
            <xs:enumeration value="ApplicableScenario">
                <xs:annotation>
                    <xs:documentation>This role type specifies that a condition is used to determine
                        whether or not a particular knowledge component should be executed. If the
                        expression evaluates to true, then the component is
                        executed.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <!-- 	<xs:enumeration value="Inclusion"></xs:enumeration>
			<xs:enumeration value="Exclusion"></xs:enumeration>
			<xs:enumeration value="Precondition"></xs:enumeration>
			<xs:enumeration value="Postcondition"></xs:enumeration> -->
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ConditionRoleTypeExt">
        <xs:restriction base="ConditionRoleTypeCore"/>
    </xs:simpleType>
    <xs:simpleType name="ConditionRoleType">
        <xs:annotation>
            <xs:documentation>The roles that a condition plays in the execution     of a component.
                Currently, only one role type is defined. Additional     role types may be defined
                in the future (e.g., inclusion criteria,     exclusion criteria)</xs:documentation>
        </xs:annotation>
        <xs:union memberTypes="ConditionRoleTypeCore ConditionRoleTypeExt"/>
    </xs:simpleType>
    <xs:complexType name="Condition">
        <xs:annotation>
            <xs:documentation>A condition specifies when a knowledge component is     to be
                executed. For example, an ECA rule uses an ApplicableScenario     condition to
                determine whether or not the action described by     the artifact should be
                executed.    </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element form="qualified" name="logic" type="Expression">
                <xs:annotation>
                    <xs:documentation>The logic specification of the condition. Often,       though
                        not necessarily, the logic is an expression about patient       data. The
                        expression must evaluate to a Boolean value.      </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element form="qualified" name="conditionRole">
                <xs:annotation>
                    <xs:documentation>The role determines when to evaluate the       expression and
                        how to proceed based on the expression results.       Different artifact
                        types use different types of conditions to       control various aspects of
                        the artifact. See the condition role       type enumeration documentation
                        for more discussion.      </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:attribute name="value" type="ConditionRoleType"/>
                </xs:complexType>
            </xs:element>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="Conditions">
        <xs:annotation>
            <xs:documentation>A collection of conditions that are used to     define whether various
                aspects of the artifact, such as     whether or not a particular action should be
                executed, or     whether a particular order set item is applicable to a      given
                patient.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element form="qualified" maxOccurs="unbounded" name="condition" type="Condition"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType abstract="true" name="ActionBase">
        <xs:annotation>
            <xs:documentation>Actions are the output of the CDS system and     represent the tasks
                that must be carried out by a human or a     computer system.    </xs:documentation>
        </xs:annotation>
        <xs:sequence minOccurs="0">
            <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="actionId" type="dt:II">
                <xs:annotation>
                    <xs:documentation>An identifier for the action. The identifier must       be
                        unique within the scope of the artifact.      </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element form="qualified" minOccurs="0" name="supportingEvidence"
                type="SupportingEvidence">
                <xs:annotation>
                    <xs:documentation>The evidence grade and the sources of evidence
                        associated with this artifact.      </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element form="qualified" minOccurs="0" name="supportingResources"
                type="SupportingResource">
                <xs:annotation>
                    <xs:documentation>Didactic or other informational resources       associated
                        with the action that can be provided to the CDS       recipient. Information
                        resources can include inline text       commentary and links to web
                        resources.      </xs:documentation>
                </xs:annotation>
            </xs:element>
            <!-- TODO -->
            <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="actors">
                <xs:complexType>
                    <xs:sequence>
                        <xs:element form="qualified" maxOccurs="unbounded" name="actor" type="Actor">
                            <xs:annotation>
                                <xs:documentation>The actor that is responsible for executing
                                    the action.           This element is used when an artifact can
                                    have          multiple actors          responsible for the
                                    execution of various CDS          actions,          forexample,
                                    an interdisciplinary plan of care.           It is
                                    important to note the distinction between a CDS action and
                                    an          ensuing clinical action. A CDS action might be to
                                    order          patient          ambulation, the actor for which
                                    is a physician          responsible for          writing the
                                    order. A nurse might be responsible          for ensuring
                                    that the patient ambulates. In this case, the          artifact
                                    will          specify the physician as the actor.
                                </xs:documentation>
                            </xs:annotation>
                        </xs:element>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
            <xs:element form="qualified" minOccurs="0" name="behaviors" type="Behaviors">
                <xs:annotation>
                    <xs:documentation>The behaviors associated with how the action is
                        presented and executed. The semantics and the validity of       behaviors
                        for actions are described elsewhere.      </xs:documentation>
                </xs:annotation>
            </xs:element>
            <!-- Additional conditions specific to the action execution -->
            <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="conditions"
                type="Conditions">
                <xs:annotation>
                    <xs:documentation>The conditions section lists all conditions that       pertain
                        to the action. Conditions define the logic that determine       the
                        applicability of the action in the given context, any       precondition or
                        post condition, and/or any inclusion and exclusion       criteria for the
                        given action.      </xs:documentation>
                </xs:annotation>
            </xs:element>
            <!-- <xs:element name="applicableScenario" type="Expression" minOccurs="0" 
				maxOccurs="1"> <xs:annotation> <xs:documentation>The clinical (sub) scenario 
				in which this action is applicable. This scenario is additive to any scenarios 
				specified in the containers of this action such as action groups or the knowledge 
				document. In other words, this scenario does not override the scenario constraints 
				specified in the container elements. </xs:documentation> </xs:annotation> 
				</xs:element> -->
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="ActionGroup">
        <xs:annotation>
            <xs:documentation>This type of action is used to organize a group of     related actions
                into one container.      The semantics of how the group's     subelements interact
                with which each     other and how the subelements     might be presented are
                specified in     the group behavior.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ActionBase">
                <xs:sequence>
                    <xs:element form="qualified" minOccurs="0" name="title" type="dt:ST">
                        <xs:annotation>
                            <xs:documentation>A brief title that is shown to the user of the
                                artifact, i.e., the recipient of the CDS        </xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element form="qualified" minOccurs="0" name="description" type="dt:ST">
                        <xs:annotation>
                            <xs:documentation>A lengthier description of the action group
                                that can         be displayed to the user or the recipient of the
                                CDS        </xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element form="qualified" minOccurs="0" name="representedConcepts">
                        <xs:annotation>
                            <xs:documentation>The concept(s) represented by this action group. For
                                instance, a section may represent a group of beta-blockers, a
                                composite orderable such as an insulin sliding scale, or a set of
                                order sentences for a particular orderable (e.g.,
                                Tylenol).</xs:documentation>
                        </xs:annotation>
                        <xs:complexType>
                            <xs:sequence>
                                <xs:element form="qualified" maxOccurs="unbounded" name="concept"
                                    type="dt:CD"/>
                            </xs:sequence>
                        </xs:complexType>
                    </xs:element>
                    <xs:element form="qualified" name="subElements">
                        <xs:annotation>
                            <xs:documentation>The constituent elements of the group can be of
                                different types including subgroups, simple or atomic actions,
                                and subgroups embedded by reference.          While the group allows
                                artifacts of different types to be mixed and         matched in any
                                combination, a particular type of artifact might         further
                                restrict         the combinations. For example, an artifact type
                                might require         subelements of a particular group to be either
                                groups or simple         actions; elements of both types cannot
                                exist in         the group.        </xs:documentation>
                        </xs:annotation>
                        <xs:complexType>
                            <xs:sequence>
                                <xs:choice maxOccurs="unbounded">
                                    <xs:element form="qualified" name="simpleAction"
                                        type="AtomicAction">
                                        <xs:annotation>
                                            <xs:documentation>The subelement is an atomic or single
                                                action.            </xs:documentation>
                                        </xs:annotation>
                                    </xs:element>
                                    <xs:element form="qualified" name="actionGroup"
                                        type="ActionGroup">
                                        <xs:annotation>
                                            <xs:documentation>This subelement is a group of actions
                                                that             are specified in line.
                                            </xs:documentation>
                                        </xs:annotation>
                                    </xs:element>
                                    <xs:element form="qualified" name="actionGroupReference"
                                        type="VersionedIdentifier">
                                        <xs:annotation>
                                            <xs:documentation>A group can be included in an artifact
                                                or             another group by reference. This is
                                                accomplished by             specifying its
                                                identifier. The latter specifies the
                                                identifier of an artifact containing the referenced
                                                group.            </xs:documentation>
                                        </xs:annotation>
                                    </xs:element>
                                </xs:choice>
                            </xs:sequence>
                        </xs:complexType>
                    </xs:element>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType abstract="true" name="AtomicAction">
        <xs:annotation>
            <xs:documentation>An action that is not further broken down into     constituent
                actions.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ActionBase">
                <xs:sequence>
                    <xs:element form="qualified" minOccurs="0" name="textEquivalent" type="dt:ST">
                        <xs:annotation>
                            <xs:documentation>A brief textual description of the action that
                                summarizes the action        </xs:documentation>
                        </xs:annotation>
                    </xs:element>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="CreateAction">
        <xs:annotation>
            <xs:documentation>A new action to be executed by a user or a computer     system. The
                sentence provides the details of the action to be     executed.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="AtomicAction">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="actionSentence"
                        type="Expression">
                        <xs:annotation>
                            <xs:documentation>The parameters of the action that is to be
                                executed. For example, an action may be to order a medication.
                            </xs:documentation>
                        </xs:annotation>
                    </xs:element>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="UpdateAction">
        <xs:annotation>
            <xs:documentation>This action changing the value of another     existing     action. The
                action being modified may be a proposed     action (e.g., an     medication being
                prescribed by a clinician) or be     an ongoing action     (e.g., an existing
                prescription). In these cases,     a modification can     be used to change the dose
                of the medication. It     may also be used to     discontinue a medication by
                changing the stop     date.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="AtomicAction">
                <xs:sequence>
                    <xs:element form="qualified" name="actionSentence" type="ObjectRedefine">
                        <xs:annotation>
                            <xs:documentation>The modification to the action. This is
                                specified by modifying the property of an existing action using
                                the ObjectRedefine expression.        </xs:documentation>
                        </xs:annotation>
                    </xs:element>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="RemoveAction">
        <xs:annotation>
            <xs:documentation>This action removes another proposed action or an     ongoing action.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="AtomicAction">
                <xs:sequence>
                    <xs:element form="qualified" name="actionSentence" type="Expression">
                        <xs:annotation>
                            <xs:documentation>The expression must resolve to the action that
                                is being removed.        </xs:documentation>
                        </xs:annotation>
                    </xs:element>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="FireEventAction">
        <xs:annotation>
            <xs:documentation>This action fires an event. The event can serve as     a trigger to
                another artifact.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="AtomicAction">
                <xs:sequence>
                    <xs:element form="qualified" name="eventType" type="EventType">
                        <xs:annotation>
                            <xs:documentation>The type of the event that is fired.
                            </xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="actionSentence"
                        type="Expression">
                        <xs:annotation>
                            <xs:documentation>The action sentence is the payload of the
                                event. Another artifact receives this payload as an input.
                            </xs:documentation>
                        </xs:annotation>
                    </xs:element>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="DeclareResponseAction">
        <xs:annotation>
            <xs:documentation>     The DeclareResponseAction provides a mechanism to declare a
                container for responses provided by the user     in response to
                CollectInformationActions. The intended semantics are to provide a container that
                can be     used to access responses within expressions used subsequently in an
                artifact.      The DeclareResponseAction creates a named container within the
                Parameters scope of the artifact, and expressions     may access the contents of a
                response using a ParameterRef expression.      The container is expected to be a
                collection of name-value pairs, and the intended semantics are to allow the
                Property expression to be used, in connection with a ParameterRef expression as the
                source, to retrieve the current     value for a property.      The
                CollectInformationAction contains a responseBinding attribute that specifies the
                name of the container, and the     name of the property to be used to store the
                response value.      If no Name attribute is provided, the response container will
                be named Responses.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="AtomicAction">
                <xs:attribute default="Responses" name="name" type="xs:string" use="optional"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="ResponseBinding">
        <xs:annotation>
            <xs:documentation>     Defines the attributes required to specify a binding path for
                documentation item responses.      The container attribute specifies the name of the
                response container that will be used. If     no container attribute is provided, the
                default container name of Responses will be used.      The property attribute
                specifies the name of the property within the container that will be      used to
                store the user response value.    </xs:documentation>
        </xs:annotation>
        <xs:attribute default="Responses" name="container" type="xs:string" use="optional"/>
        <xs:attribute name="property" type="xs:string" use="required"/>
    </xs:complexType>
    <xs:complexType name="CollectInformationAction">
        <xs:annotation>
            <xs:documentation>This action requests information from the actor. The     information
                request is specified as a DocumentationItem.    </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="AtomicAction">
                <xs:sequence>
                    <xs:element form="qualified" name="documentationConcept"
                        type="DocumentationItem">
                        <xs:annotation>
                            <xs:documentation>This provides a specification of the
                                information to be collected from the user.
                            </xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="initialValue"
                        type="Expression">
                        <xs:annotation>
                            <xs:documentation>An expression to compute an initial value for
                                the documentation concept. The initial value could be computed
                                from previous data about the patient available via expressions
                                specified in the external data        </xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element form="qualified" maxOccurs="1" minOccurs="0" name="responseBinding"
                        type="ResponseBinding">
                        <xs:annotation>
                            <xs:documentation>Defines the response binding for the documentation
                                item.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:element name="knowledgeDocument" type="KnowledgeDocument">
        <xs:annotation>
            <xs:documentation>knowledgeDocument represents a serialized Clinical Decision Support
                (CDS) knowledge artifact. It is intended to define a general serialization format
                for an Order Set, a Event-Condition-Action (ECA) Rule, and a Document Template.
                Given the general intended purpose for this schema, it is important to note that the
                serialization of a given CDS artifact is defined by both this schema, in conjunction
                with a template defining artifact-specific constraints. For additional information
                on these artifact-specific constraints, please refer to the Implementation
                Guide.</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="KnowledgeDocument">
        <xs:annotation>
            <xs:documentation>A knowledge document is an instance of a CDS     knowledge artifact
                such as a rule, an order set, or a documentation     template    </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element maxOccurs="1" minOccurs="1" name="metadata" type="Metadata">
                <xs:annotation>
                    <xs:documentation>The metadata section of the knowledge document defines the
                        core metadata associated with this CDS knowledge artifact such as (1) the
                        unique identifier for this artifact, (2) the unique identifier for its
                        associated template(s), (3) the title and description of the artifact, (4)
                        the status and history of the artifact, (5) any relevant entities associated
                        with this artifact, and (6) information needed to categorize and retrieve
                        the artifact.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <!-- Probably should constrain using schematron the expression type to 
				Request -->
            <xs:element maxOccurs="1" minOccurs="0" name="externalData">
                <xs:annotation>
                    <xs:documentation>The externalData section allows a CDS artifact author to
                        define 'named expressions' to fetch information from an external source and
                        bind this information to the 'context' of the knowledge artifact for later
                        reference by the logic modules (e.g., the condition for the knowledge
                        artifact or actions). It is the responsibility of the implementation to
                        determine the nature of this boundary and how to fetch this information. For
                        instance, one may write an expression to retrieve from a patient vMR the age
                        of a patient or a list of clinical problems whose problem code are contained
                        in a given ICD-9 value set. The age value and the list of patient problems
                        may then be used in the 'condition' section of the same knowledge artifact
                        to determine the applicability of the knowledge document to the given
                        patient.</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:element maxOccurs="unbounded" minOccurs="0" name="parameter"
                            type="ParameterDef">
                            <xs:annotation>
                                <xs:documentation>The parameter element define a parameters for the
                                    knowledge document. Parameters are expected to be provided by
                                    the caller when an evaluation is performed. Parameters can be
                                    referenced within any expression using a ParameterRef
                                    expression.  For instance, one may define a MonthThreshold
                                    parameter, and use this parameter to determine whether the span
                                    of time that has elapsed since the last A1C has been performed
                                    warrants the elicitation of a reminder.
                                </xs:documentation>
                            </xs:annotation>
                        </xs:element>
                        <xs:element maxOccurs="unbounded" minOccurs="0" name="def"
                            type="ExpressionDef">
                            <xs:annotation>
                                <xs:documentation>The named expression used to retrieve external
                                    data. For instance, an expression to retrieve patient
                                    demographic data or a set of SNOMED-CT codes subsumed by another
                                    SNOMED-CT code from a terminology server.</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
            <xs:element maxOccurs="1" minOccurs="0" name="expressions">
                <xs:annotation>
                    <xs:documentation>The expressions section allows a CDS artifact author to define
                        'named expressions' that can be referenced anywhere within expressions in
                        the artifact. This allows expression logic to be reused, as well as to be
                        organized for readability and maintainability.</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:element maxOccurs="unbounded" minOccurs="0" name="def"
                            type="ExpressionDef"/>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
            <xs:element maxOccurs="1" minOccurs="0" name="triggers" type="Triggers">
                <xs:annotation>
                    <xs:documentation>The triggers section defines the list of all triggers that
                        'activate' or 'trigger' the CDS knowledge artifact. For instance, opening a
                        patient record may trigger a rule to execute if the conditions of the rule
                        are met. </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element maxOccurs="1" minOccurs="0" name="conditions" type="Conditions">
                <xs:annotation>
                    <xs:documentation>The conditions section lists all conditions that pertain to
                        the knowledge artifact. Conditions define the logic that determine the
                        applicability of the artifact in the given context, any precondition or post
                        condition, and/or any inclusion and exclusion criteria for the given CDS
                        artifact.  Conditions are structured as expressions to be evaluated in the
                        target system.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element maxOccurs="1" minOccurs="0" name="behaviors" type="Behaviors">
                <xs:annotation>
                    <xs:documentation>The behaviors section defines the set of behaviors for this
                        knowledge document.  While there are no artifact-level behaviors defined at
                        this time, this element is included as a point of extension, should it be
                        needed.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <!-- actions -->
            <xs:element maxOccurs="1" minOccurs="1" name="actionGroup" type="ActionGroup">
                <xs:annotation>
                    <xs:documentation>The actionGroups is essentially the top-level container for
                        the groups of actions that make up a given knowledge document. This
                        container defines the main content of the knowledge artifact: logical
                        grouping constructs such as the clinical sections and orderables in an order
                        set, the tasks to be performed by a rule, or the sections and menu choices
                        that make up a document template. </xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="Trigger">
        <xs:sequence>
            <xs:element name="eventType" type="EventType">
                <xs:annotation>
                    <xs:documentation>The event type can be one of either a DataEvent or a
                        PeriodicEvent. A DataEvent is an event that is triggered by the value,
                        presence, or absence of a particular data item. For instance, a data event
                        may be triggered by a new serum potassium result below 3.5, a new
                        appointment event to a Primary Care Clinic, or a new susbstance
                        administration proposal for dabigatran. A periodic event is an event that is
                        triggered on a regular basis. For instance, every day at midnight.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element minOccurs="0" name="expression" type="Expression">
                <xs:annotation>
                    <xs:documentation>The event expression that must be met for the trigger to
                        activate the record.</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="Triggers">
        <xs:sequence>
            <xs:element maxOccurs="unbounded" name="trigger" type="Trigger">
                <xs:annotation>
                    <xs:documentation>The trigger element represents an event that 'triggers' the
                        knowledge artifact. For instance, 'evaluate this artifact whenever a new
                        Problem with a Diabetes Diagnosis code is added to the patient's record' or
                        'Evaluate this artifact every week day at 10:00 PM'. A trigger can model
                        either a data event or a periodic event.</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:complexType>
</xs:schema>
